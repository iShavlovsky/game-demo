import{c as G,s as Mt,p as At}from"./zustand-YPADddZo.js";import{g as W,S as st,n as it,U as P,w as kt,a as $t,R as H,c as ft,p as xt,b as Tt,d as Et,m as Wt,r as qt,C as ht,h as pt,t as Dt,f as gt,e as Ft,i as Rt,s as Nt,j as Bt,k as Ut,l as Kt,o as zt,q as Lt}from"./viem-B4i6e-Ob.js";import{E as Gt}from"./eventemitter3-DVaOc9f-.js";import{c as Ht}from"./mipd-CIcDX0W7.js";import{u as U,h as Vt,i as Qt,x as Jt,t as Zt,k as tt,o as q,a as mt,c as K,r as et}from"./@vue-O2P8gYLh.js";import{u as Xt,a as yt}from"./@tanstack-CLvYTB17.js";class Yt{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Gt})}on(n,e){this._emitter.on(n,e)}once(n,e){this._emitter.once(n,e)}off(n,e){this._emitter.off(n,e)}emit(n,...e){const r=e[0];this._emitter.emit(n,{uid:this.uid,...r})}listenerCount(n){return this._emitter.listenerCount(n)}}function te(t){return new Yt(t)}function ee(t,n){return JSON.parse(t,(e,r)=>{let o=r;return(o==null?void 0:o.__type)==="bigint"&&(o=BigInt(o.value)),(o==null?void 0:o.__type)==="Map"&&(o=new Map(o.value)),(n==null?void 0:n(e,o))??o})}function at(t,n){return t.slice(0,n).join(".")||"."}function ut(t,n){const{length:e}=t;for(let r=0;r<e;++r)if(t[r]===n)return r+1;return 0}function ne(t,n){const e=typeof t=="function",r=typeof n=="function",o=[],c=[];return function(u,a){if(typeof a=="object")if(o.length){const s=ut(o,this);s===0?o[o.length]=this:(o.splice(s),c.splice(s)),c[c.length]=u;const h=ut(o,a);if(h!==0)return r?n.call(this,u,a,at(c,h)):`[ref=${at(c,h)}]`}else o[0]=a,c[0]=u;return e?t.call(this,u,a):a}}function re(t,n,e,r){return JSON.stringify(t,ne((o,c)=>{let i=c;return typeof i=="bigint"&&(i={__type:"bigint",value:c.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(c.entries())}),(n==null?void 0:n(o,i))??i},r),e??void 0)}function oe(t){const{deserialize:n=ee,key:e="wagmi",serialize:r=re,storage:o=bt}=t;function c(i){return i instanceof Promise?i.then(u=>u).catch(()=>null):i}return{...o,key:e,async getItem(i,u){const a=o.getItem(`${e}.${i}`),s=await c(a);return s?n(s)??null:u??null},async setItem(i,u){const a=`${e}.${i}`;u===null?await c(o.removeItem(a)):await c(o.setItem(a,r(u)))},async removeItem(i){await c(o.removeItem(`${e}.${i}`))}}}const bt={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function tn(t){return t}const N="2.10.4",ce=()=>`@wagmi/core@${N}`;var wt=function(t,n,e,r){if(e==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?t!==n||!r:!n.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?r:e==="a"?r.call(t):r?r.value:n.get(t)},z,Ct;let E=class J extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return ce()}constructor(n,e={}){var c;super(),z.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const r=e.cause instanceof J?e.cause.details:(c=e.cause)!=null&&c.message?e.cause.message:e.details,o=e.cause instanceof J&&e.cause.docsPath||e.docsPath;this.message=[n||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...o?[`Docs: ${this.docsBaseUrl}${o}.html${e.docsSlug?`#${e.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),e.cause&&(this.cause=e.cause),this.details=r,this.docsPath=o,this.metaMessages=e.metaMessages,this.shortMessage=n}walk(n){return wt(this,z,"m",Ct).call(this,this,n)}};z=new WeakSet,Ct=function t(n,e){return e!=null&&e(n)?n:n.cause?wt(this,z,"m",t).call(this,n.cause,e):n};class Z extends E{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class se extends E{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class ie extends E{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class ae extends E{constructor({address:n,connector:e}){super(`Account "${n}" not found for connector "${e.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class x extends E{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const ue=/(rabby|trustwallet)/,de={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t!=null&&t.coinbaseWalletExtension?t.coinbaseWalletExtension:B(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return B(t,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const e=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const r of e)if(n[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){var n,e;return(n=t==null?void 0:t.phantom)!=null&&n.ethereum?(e=t.phantom)==null?void 0:e.ethereum:B(t,"isPhantom")}}};nt.type="injected";function nt(t={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:e}=t;function r(){const a=t.target;if(typeof a=="function"){const s=a();if(s)return s}return typeof a=="object"?a:typeof a=="string"?{...de[a]??{id:a,name:`${a[0].toUpperCase()}${a.slice(1)}`,provider:`is${a[0].toUpperCase()}${a.slice(1)}`}}:{id:"injected",name:"Injected",provider(s){return s==null?void 0:s.ethereum}}}let o,c,i,u;return a=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return ue.test(this.id.toLowerCase())},type:nt.type,async setup(){const s=await this.getProvider();s&&t.target&&(i||(i=this.onConnect.bind(this),s.on("connect",i)),o||(o=this.onAccountsChanged.bind(this),s.on("accountsChanged",o)))},async connect({chainId:s,isReconnecting:h}={}){var C,m,O,y,v,S;const l=await this.getProvider();if(!l)throw new x;let g=[];if(h)g=await this.getAccounts().catch(()=>[]);else if(n)try{g=(y=(O=(m=(C=(await l.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:C.caveats)==null?void 0:m[0])==null?void 0:O.value)==null?void 0:y.map(d=>W(d))}catch(I){const d=I;if(d.code===P.code)throw new P(d);if(d.code===H.code)throw d}try{!(g!=null&&g.length)&&!h&&(g=(await l.request({method:"eth_requestAccounts"})).map(p=>W(p))),i&&(l.removeListener("connect",i),i=void 0),o||(o=this.onAccountsChanged.bind(this),l.on("accountsChanged",o)),c||(c=this.onChainChanged.bind(this),l.on("chainChanged",c)),u||(u=this.onDisconnect.bind(this),l.on("disconnect",u));let I=await this.getChainId();if(s&&I!==s){const d=await this.switchChain({chainId:s}).catch(p=>{if(p.code===P.code)throw p;return{id:I}});I=(d==null?void 0:d.id)??I}return n&&await((v=a.storage)==null?void 0:v.removeItem(`${this.id}.disconnected`)),t.target||await((S=a.storage)==null?void 0:S.setItem("injected.connected",!0)),{accounts:g,chainId:I}}catch(I){const d=I;throw d.code===P.code?new P(d):d.code===H.code?new H(d):d}},async disconnect(){var h,l;const s=await this.getProvider();if(!s)throw new x;c&&(s.removeListener("chainChanged",c),c=void 0),u&&(s.removeListener("disconnect",u),u=void 0),i||(i=this.onConnect.bind(this),s.on("connect",i));try{await s.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((h=a.storage)==null?void 0:h.setItem(`${this.id}.disconnected`,!0)),t.target||await((l=a.storage)==null?void 0:l.removeItem("injected.connected"))},async getAccounts(){const s=await this.getProvider();if(!s)throw new x;return(await s.request({method:"eth_accounts"})).map(l=>W(l))},async getChainId(){const s=await this.getProvider();if(!s)throw new x;const h=await s.request({method:"eth_chainId"});return Number(h)},async getProvider(){if(typeof window>"u")return;let s;const h=r();return typeof h.provider=="function"?s=h.provider(window):typeof h.provider=="string"?s=B(window,h.provider):s=h.provider,s&&!s.removeListener&&("off"in s&&typeof s.off=="function"?s.removeListener=s.off:s.removeListener=()=>{}),s},async isAuthorized(){var s,h;try{if(n&&await((s=a.storage)==null?void 0:s.getItem(`${this.id}.disconnected`))||!t.target&&!await((h=a.storage)==null?void 0:h.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(e!==void 0&&e!==!1){const m=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",m),!!await this.getProvider()),O=typeof e=="number"?e:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(v=>window.addEventListener("ethereum#initialized",()=>v(m()),{once:!0}))]:[],new Promise(v=>setTimeout(()=>v(m()),O))]))return!0}throw new x}return!!(await kt(()=>$t(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:s,chainId:h}){var C,m,O,y;const l=await this.getProvider();if(!l)throw new x;const g=a.chains.find(v=>v.id===h);if(!g)throw new st(new Z);try{return await Promise.all([l.request({method:"wallet_switchEthereumChain",params:[{chainId:it(h)}]}).then(async()=>{await this.getChainId()===h&&a.emitter.emit("change",{chainId:h})}),new Promise(v=>a.emitter.once("change",({chainId:S})=>{S===h&&v()}))]),g}catch(v){const S=v;if(S.code===4902||((m=(C=S==null?void 0:S.data)==null?void 0:C.originalError)==null?void 0:m.code)===4902)try{const{default:I,...d}=g.blockExplorers??{};let p;s!=null&&s.blockExplorerUrls?p=s.blockExplorerUrls:I&&(p=[I.url,...Object.values(d).map($=>$.url)]);let f;(O=s==null?void 0:s.rpcUrls)!=null&&O.length?f=s.rpcUrls:f=[((y=g.rpcUrls.default)==null?void 0:y.http[0])??""];const b={blockExplorerUrls:p,chainId:it(h),chainName:(s==null?void 0:s.chainName)??g.name,iconUrls:s==null?void 0:s.iconUrls,nativeCurrency:(s==null?void 0:s.nativeCurrency)??g.nativeCurrency,rpcUrls:f};if(await l.request({method:"wallet_addEthereumChain",params:[b]}),await this.getChainId()!==h)throw new P(new Error("User rejected switch after adding network."));return g}catch(I){throw new P(I)}throw S.code===P.code?new P(S):new st(S)}},async onAccountsChanged(s){var h;if(s.length===0)this.onDisconnect();else if(a.emitter.listenerCount("connect")){const l=(await this.getChainId()).toString();this.onConnect({chainId:l}),n&&await((h=a.storage)==null?void 0:h.removeItem(`${this.id}.disconnected`))}else a.emitter.emit("change",{accounts:s.map(l=>W(l))})},onChainChanged(s){const h=Number(s);a.emitter.emit("change",{chainId:h})},async onConnect(s){const h=await this.getAccounts();if(h.length===0)return;const l=Number(s.chainId);a.emitter.emit("connect",{accounts:h,chainId:l});const g=await this.getProvider();g&&(i&&(g.removeListener("connect",i),i=void 0),o||(o=this.onAccountsChanged.bind(this),g.on("accountsChanged",o)),c||(c=this.onChainChanged.bind(this),g.on("chainChanged",c)),u||(u=this.onDisconnect.bind(this),g.on("disconnect",u)))},async onDisconnect(s){const h=await this.getProvider();s&&s.code===1013&&h&&(await this.getAccounts()).length||(a.emitter.emit("disconnect"),h&&(c&&(h.removeListener("chainChanged",c),c=void 0),u&&(h.removeListener("disconnect",u),u=void 0),i||(i=this.onConnect.bind(this),h.on("connect",i))))}})}function B(t,n){function e(o){return typeof n=="function"?n(o):typeof n=="string"?o[n]:!0}const r=t.ethereum;if(r!=null&&r.providers)return r.providers.find(o=>e(o));if(r&&e(r))return r}const X=256;let D=X,F;function le(t=11){if(!F||D+t>X*2){F="",D=0;for(let n=0;n<X;n++)F+=(256+Math.random()*256|0).toString(16).substring(1)}return F.substring(D,D+++t)}function en(t){const{multiInjectedProviderDiscovery:n=!0,storage:e=oe({storage:typeof window<"u"&&window.localStorage?window.localStorage:bt}),syncConnectedChain:r=!0,ssr:o,...c}=t,i=typeof window<"u"&&n?Ht():void 0,u=G(()=>c.chains),a=G(()=>[...c.connectors??[],...o?[]:(i==null?void 0:i.getProviders().map(h))??[]].map(s));function s(d){var b;const p=te(le()),f={...d({emitter:p,chains:u.getState(),storage:e}),emitter:p,uid:p.uid};return p.on("connect",S),(b=f.setup)==null||b.call(f),f}function h(d){const{info:p}=d,f=d.provider;return nt({target:{...p,id:p.rdns,provider:f}})}const l=new Map;function g(d={}){const p=d.chainId??y.getState().chainId,f=u.getState().find(w=>w.id===p);if(d.chainId&&!f)throw new Z;{const w=l.get(y.getState().chainId);if(w&&!f)return w;if(!f)throw new Z}{const w=l.get(p);if(w)return w}let b;if(c.client)b=c.client({chain:f});else{const w=f.id,$=u.getState().map(j=>j.id),M={},L=Object.entries(c);for(const[j,A]of L)if(!(j==="chains"||j==="client"||j==="connectors"||j==="transports"))if(typeof A=="object")if(w in A)M[j]=A[w];else{if($.some(ct=>ct in A))continue;M[j]=A}else M[j]=A;b=ft({...M,chain:f,batch:M.batch??{multicall:!0},transport:j=>c.transports[w]({...j,connectors:a})})}return l.set(p,b),b}function C(){return{chainId:u.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let m;const O="0.0.0-canary-";N.startsWith(O)?m=parseInt(N.replace(O,"")):m=parseInt(N.split(".")[0]??"0");const y=G(Mt(e?At(C,{migrate(d,p){if(p===m)return d;const f=C(),b=d&&typeof d=="object"&&"chainId"in d&&typeof d.chainId=="number"?d.chainId:f.chainId;return{...f,chainId:b}},name:"store",partialize(d){return{connections:{__type:"Map",value:Array.from(d.connections.entries()).map(([p,f])=>{const{id:b,name:w,type:$,uid:M}=f.connector;return[p,{...f,connector:{id:b,name:w,type:$,uid:M}}]})},chainId:d.chainId,current:d.current}},skipHydration:o,storage:e,version:m}):C));r&&y.subscribe(({connections:d,current:p})=>{var f;return p?(f=d.get(p))==null?void 0:f.chainId:void 0},d=>{if(u.getState().some(f=>f.id===d))return y.setState(f=>({...f,chainId:d??f.chainId}))}),i==null||i.subscribe(d=>{const p=new Map;for(const b of a.getState())p.set(b.id,!0);const f=[];for(const b of d){const w=s(h(b));p.has(w.id)||f.push(w)}e&&!y.persist.hasHydrated()||a.setState(b=>[...b,...f],!0)});function v(d){y.setState(p=>{const f=p.connections.get(d.uid);return f?{...p,connections:new Map(p.connections).set(d.uid,{accounts:d.accounts??f.accounts,chainId:d.chainId??f.chainId,connector:f.connector})}:p})}function S(d){y.getState().status==="connecting"||y.getState().status==="reconnecting"||y.setState(p=>{const f=a.getState().find(b=>b.uid===d.uid);return f?(f.emitter.listenerCount("connect")&&f.emitter.off("connect",v),f.emitter.listenerCount("change")||f.emitter.on("change",v),f.emitter.listenerCount("disconnect")||f.emitter.on("disconnect",I),{...p,connections:new Map(p.connections).set(d.uid,{accounts:d.accounts,chainId:d.chainId,connector:f}),current:d.uid,status:"connected"}):p})}function I(d){y.setState(p=>{const f=p.connections.get(d.uid);if(f){const w=f.connector;w.emitter.listenerCount("change")&&f.connector.emitter.off("change",v),w.emitter.listenerCount("disconnect")&&f.connector.emitter.off("disconnect",I),w.emitter.listenerCount("connect")||f.connector.emitter.on("connect",S)}if(p.connections.delete(d.uid),p.connections.size===0)return{...p,connections:new Map,current:null,status:"disconnected"};const b=p.connections.values().next().value;return{...p,connections:new Map(p.connections),current:b.connector.uid}})}return{get chains(){return u.getState()},get connectors(){return a.getState()},storage:e,getClient:g,get state(){return y.getState()},setState(d){let p;typeof d=="function"?p=d(y.getState()):p=d;const f=C();typeof p!="object"&&(p=f),Object.keys(f).some(w=>!(w in p))&&(p=f),y.setState(p,!0)},subscribe(d,p,f){return y.subscribe(d,p,f?{...f,fireImmediately:f.emitImmediately}:void 0)},_internal:{mipd:i,store:y,ssr:!!o,syncConnectedChain:r,transports:c.transports,chains:{setState(d){const p=typeof d=="function"?d(u.getState()):d;if(p.length!==0)return u.setState(p,!0)},subscribe(d){return u.subscribe(d)}},connectors:{providerDetailToConnector:h,setup:s,setState(d){return a.setState(typeof d=="function"?d(a.getState()):d,!0)},subscribe(d){return a.subscribe(d)}},events:{change:v,connect:S,disconnect:I}}}}function _(t,n,e){const r=t[n.name];if(typeof r=="function")return r;const o=t[e];return typeof o=="function"?o:c=>n(t,c)}async function fe(t,n){var r;let e;if(typeof n.connector=="function"?e=t._internal.connectors.setup(n.connector):e=n.connector,e.uid===t.state.current)throw new se;try{t.setState(i=>({...i,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});const o=await e.connect({chainId:n.chainId}),c=o.accounts;return e.emitter.off("connect",t._internal.events.connect),e.emitter.on("change",t._internal.events.change),e.emitter.on("disconnect",t._internal.events.disconnect),await((r=t.storage)==null?void 0:r.setItem("recentConnectorId",e.id)),t.setState(i=>({...i,connections:new Map(i.connections).set(e.uid,{accounts:c,chainId:o.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:c,chainId:o.chainId}}catch(o){throw t.setState(c=>({...c,status:c.current?"connected":"disconnected"})),o}}async function he(t,n={}){var o,c;let e;if(n.connector)e=n.connector;else{const{connections:i,current:u}=t.state,a=i.get(u);e=a==null?void 0:a.connector}const r=t.state.connections;e&&(await e.disconnect(),e.emitter.off("change",t._internal.events.change),e.emitter.off("disconnect",t._internal.events.disconnect),e.emitter.on("connect",t._internal.events.connect),r.delete(e.uid)),t.setState(i=>{if(r.size===0)return{...i,connections:new Map,current:null,status:"disconnected"};const u=r.values().next().value;return{...i,connections:new Map(r),current:u.connector.uid}});{const i=t.state.current;if(!i)return;const u=(o=t.state.connections.get(i))==null?void 0:o.connector;if(!u)return;await((c=t.storage)==null?void 0:c.setItem("recentConnectorId",u.id))}}async function rt(t,n={}){let e;if(n.connector){const{connector:a}=n,[s,h]=await Promise.all([a.getAccounts(),a.getChainId()]);e={accounts:s,chainId:h,connector:a}}else e=t.state.connections.get(t.state.current);if(!e)throw new ie;const r=n.chainId??e.chainId,o=e.connector;if(o.getClient)return o.getClient({chainId:r});const c=xt(n.account??e.accounts[0]);c.address=W(c.address);const i=t.chains.find(a=>a.id===r),u=await e.connector.getProvider({chainId:r});if(n.account&&!e.accounts.some(a=>a.toLowerCase()===c.address.toLowerCase()))throw new ae({address:c.address,connector:o});return ft({account:c,chain:i,name:"Connector Client",transport:a=>Tt(u)({...a,retryCount:0})})}function vt(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(Et[t])}function ot(t){const n=t.state.current,e=t.state.connections.get(n),r=e==null?void 0:e.accounts,o=r==null?void 0:r[0],c=t.chains.find(u=>u.id===(e==null?void 0:e.chainId)),i=t.state.status;switch(i){case"connected":return{address:o,addresses:r,chain:c,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:i};case"reconnecting":return{address:o,addresses:r,chain:c,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!!o,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:i};case"connecting":return{address:o,addresses:r,chain:c,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:i};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:i}}}async function pe(t,n){const{allowFailure:e=!0,chainId:r,contracts:o,...c}=n,i=t.getClient({chainId:r});return _(i,Wt,"multicall")({allowFailure:e,contracts:o,...c})}function ge(t,n){const{chainId:e,...r}=n,o=t.getClient({chainId:e});return _(o,qt,"readContract")(r)}async function me(t,n){const{allowFailure:e=!0,blockNumber:r,blockTag:o,...c}=n,i=n.contracts;try{const u=i.reduce((l,g,C)=>{const m=g.chainId??t.state.chainId;return{...l,[m]:[...l[m]||[],{contract:g,index:C}]}},{}),a=()=>Object.entries(u).map(([l,g])=>pe(t,{...c,allowFailure:e,blockNumber:r,blockTag:o,chainId:parseInt(l),contracts:g.map(({contract:C})=>C)})),s=(await Promise.all(a())).flat(),h=Object.values(u).flatMap(l=>l.map(({index:g})=>g));return s.reduce((l,g,C)=>(l&&(l[h[C]]=g),l),[])}catch(u){if(u instanceof ht)throw u;const a=()=>i.map(s=>ge(t,{...s,blockNumber:r,blockTag:o}));return e?(await Promise.allSettled(a())).map(s=>s.status==="fulfilled"?{result:s.value,status:"success"}:{error:s.reason,result:void 0,status:"failure"}):await Promise.all(a())}}async function ye(t,n){const{address:e,blockNumber:r,blockTag:o,chainId:c,token:i,unit:u="ether"}=n;if(i)try{return dt(t,{balanceAddress:e,chainId:c,symbolType:"string",tokenAddress:i})}catch(g){if(g instanceof ht){const C=await dt(t,{balanceAddress:e,chainId:c,symbolType:"bytes32",tokenAddress:i}),m=pt(Dt(C.symbol,{dir:"right"}));return{...C,symbol:m}}throw g}const a=t.getClient({chainId:c}),h=await _(a,Ft,"getBalance")(r?{address:e,blockNumber:r}:{address:e,blockTag:o}),l=t.chains.find(g=>g.id===c)??a.chain;return{decimals:l.nativeCurrency.decimals,formatted:gt(h,vt(u)),symbol:l.nativeCurrency.symbol,value:h}}async function dt(t,n){const{balanceAddress:e,chainId:r,symbolType:o,tokenAddress:c,unit:i}=n,u={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:o}]}],address:c},[a,s,h]=await me(t,{allowFailure:!1,contracts:[{...u,functionName:"balanceOf",args:[e],chainId:r},{...u,functionName:"decimals",chainId:r},{...u,functionName:"symbol",chainId:r}]}),l=gt(a??"0",vt(i??s));return{decimals:s,formatted:l,symbol:h,value:a}}function be(t){return t.state.chainId}function T(t,n){if(t===n)return!0;if(t&&n&&typeof t=="object"&&typeof n=="object"){if(t.constructor!==n.constructor)return!1;let e,r;if(Array.isArray(t)&&Array.isArray(n)){if(e=t.length,e!==n.length)return!1;for(r=e;r--!==0;)if(!T(t[r],n[r]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();const o=Object.keys(t);if(e=o.length,e!==Object.keys(n).length)return!1;for(r=e;r--!==0;)if(!Object.prototype.hasOwnProperty.call(n,o[r]))return!1;for(r=e;r--!==0;){const c=o[r];if(c&&!T(t[c],n[c]))return!1}return!0}return t!==t&&n!==n}let R=[];function It(t){const n=[...t.state.connections.values()];return t.state.status==="reconnecting"||T(R,n)?R:(R=n,n)}let V=[];function we(t){const n=t.connectors;return T(V,n)?V:(V=n,n)}let Q=!1;async function Ce(t,n={}){var s,h;if(Q)return[];Q=!0,t.setState(l=>({...l,status:l.current?"reconnecting":"connecting"}));const e=[];if((s=n.connectors)!=null&&s.length)for(const l of n.connectors){let g;typeof l=="function"?g=t._internal.connectors.setup(l):g=l,e.push(g)}else e.push(...t.connectors);let r;try{r=await((h=t.storage)==null?void 0:h.getItem("recentConnectorId"))}catch{}const o={};for(const[,l]of t.state.connections)o[l.connector.id]=1;r&&(o[r]=0);const c=Object.keys(o).length>0?[...e].sort((l,g)=>(o[l.id]??10)-(o[g.id]??10)):e;let i=!1;const u=[],a=[];for(const l of c){const g=await l.getProvider().catch(()=>{});if(!g||a.some(O=>O===g)||!await l.isAuthorized())continue;const m=await l.connect({isReconnecting:!0}).catch(()=>null);m&&(l.emitter.off("connect",t._internal.events.connect),l.emitter.on("change",t._internal.events.change),l.emitter.on("disconnect",t._internal.events.disconnect),t.setState(O=>{const y=new Map(i?O.connections:new Map).set(l.uid,{accounts:m.accounts,chainId:m.chainId,connector:l});return{...O,current:i?O.current:l.uid,connections:y}}),u.push({accounts:m.accounts,chainId:m.chainId,connector:l}),a.push(g),i=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(i?t.setState(l=>({...l,status:"connected"})):t.setState(l=>({...l,connections:new Map,current:null,status:"disconnected"}))),Q=!1,u}async function nn(t,n){const{account:e,chainId:r,connector:o,gas:c,...i}=n;let u;typeof e=="object"&&e.type==="local"?u=t.getClient({chainId:r}):u=await rt(t,{account:e,chainId:r,connector:o});const{connector:a}=ot(t),s=await(async()=>{var g;if(!(!("data"in n)||!n.data)&&!((g=o??a)!=null&&g.supportsSimulation)&&c!==null)return c===void 0?_(u,Rt,"estimateGas")({...i,account:e,chain:r?{id:r}:null}):c})();return await _(u,Nt,"sendTransaction")({...i,...e?{account:e}:{},gas:s,chain:r?{id:r}:null})}async function rn(t,n){const{account:e,connector:r,...o}=n;let c;return typeof e=="object"&&e.type==="local"?c=t.getClient():c=await rt(t,{account:e,connector:r}),_(c,Bt,"signMessage")({...o,...e?{account:e}:{}})}async function on(t,n){const{account:e,connector:r,...o}=n;let c;return typeof e=="object"&&e.type==="local"?c=t.getClient():c=await rt(t,{account:e,connector:r}),_(c,Ut,"signTypedData")({...o,...e?{account:e}:{}})}function ve(t,n){const{onChange:e}=n;return t.subscribe(()=>ot(t),e,{equalityFn(r,o){const{connector:c,...i}=r,{connector:u,...a}=o;return T(i,a)&&(c==null?void 0:c.id)===(u==null?void 0:u.id)&&(c==null?void 0:c.uid)===(u==null?void 0:u.uid)}})}function Ie(t,n){const{onChange:e}=n;return t.subscribe(r=>r.chainId,e)}function Oe(t,n){const{onChange:e}=n;return t.subscribe(()=>It(t),e,{equalityFn:T})}function Se(t,n){const{onChange:e}=n;return t._internal.connectors.subscribe((r,o)=>{e(Object.values(r),o)})}async function cn(t,n){const{chainId:e,timeout:r=0,...o}=n,c=t.getClient({chainId:e}),u=await _(c,Kt,"waitForTransactionReceipt")({...o,timeout:r});if(u.status==="reverted"){const s=await _(c,zt,"getTransaction")({hash:u.transactionHash}),l=await _(c,Lt,"call")({...s,gasPrice:s.type!=="eip1559"?s.gasPrice:void 0,maxFeePerGas:s.type==="eip1559"?s.maxFeePerGas:void 0,maxPriorityFeePerGas:s.type==="eip1559"?s.maxPriorityFeePerGas:void 0}),g=l!=null&&l.data?pt(`0x${l.data.substring(138)}`):"unknown reason";throw new Error(g)}return{...u,chainId:c.chain.id}}function je(t,n){const{initialState:e,reconnectOnMount:r}=n;return e&&!t._internal.store.persist.hasHydrated()&&t.setState({...e,connections:r?e.connections:new Map,status:r?"reconnecting":"disconnected"}),{async onMount(){var o;if(t._internal.ssr){await t._internal.store.persist.rehydrate();const c=(o=t._internal.mipd)==null?void 0:o.getProviders().map(t._internal.connectors.providerDetailToConnector).map(t._internal.connectors.setup);t._internal.connectors.setState(i=>[...i,...c??[]])}r?Ce(t):t.storage&&t.setState(c=>({...c,connections:new Map}))}}}const sn={getItem(t){return typeof window>"u"?null:_e(document.cookie,t)??null},setItem(t,n){typeof window>"u"||(document.cookie=`${t}=${n}`)},removeItem(t){typeof window>"u"||(document.cookie=`${t}=;max-age=-1`)}};function _e(t,n){const e=t.split("; ").find(r=>r.startsWith(`${n}=`));if(e)return e.substring(n.length+1)}const Ot=Symbol(),an={install(t,n){const{config:e,reconnectOnMount:r=!0}=n;t.provide(Ot,e);const{onMount:o}=je(e,{...n,reconnectOnMount:r});o()}},Pe="0.0.10",Me=()=>`@wagmi/vue@${Pe}`;class St extends E{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return Me()}}class Ae extends St{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class ke extends St{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function $e(t,n){Object.keys(t).forEach(e=>{t[e]=n[e]})}function k(t={}){const n=U(t);if(n.config)return n.config;if(!Vt())throw new ke;const e=Qt(Ot);if(!e)throw new Ae;return e}function un(t={}){const n=k(t),e=Jt(ot(n)),r=ve(n,{onChange(o){$e(e,o)}});return q(()=>r()),Zt(tt(e))}function Y(t,n){if(n){const e=n(t);if(e===void 0&&mt(t)||e!==void 0)return e}if(Array.isArray(t))return t.map(e=>Y(e,n));if(typeof t=="object"&&xe(t)){const e=Object.entries(t).map(([r,o])=>[r,Y(o,n)]);return Object.fromEntries(e)}return t}function jt(t){return Y(t,n=>{if(mt(n))return jt(U(n))})}function xe(t){if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const n=Object.getPrototypeOf(t);return n===null||n===Object.prototype}function Te(t){return JSON.stringify(t,(n,e)=>Ee(e)?Object.keys(e).sort().reduce((r,o)=>(r[o]=e[o],r),{}):typeof e=="bigint"?e.toString():e)}function Ee(t){if(!lt(t))return!1;const n=t.constructor;if(typeof n>"u")return!0;const e=n.prototype;return!(!lt(e)||!e.hasOwnProperty("isPrototypeOf"))}function lt(t){return Object.prototype.toString.call(t)==="[object Object]"}function We(t){const{_defaulted:n,behavior:e,gcTime:r,initialData:o,initialDataUpdatedAt:c,maxPages:i,meta:u,networkMode:a,queryFn:s,queryHash:h,queryKey:l,queryKeyHashFn:g,retry:C,retryDelay:m,structuralSharing:O,getPreviousPageParam:y,getNextPageParam:v,initialPageParam:S,_optimisticResults:I,enabled:d,notifyOnChangeProps:p,placeholderData:f,refetchInterval:b,refetchIntervalInBackground:w,refetchOnMount:$,refetchOnReconnect:M,refetchOnWindowFocus:L,retryOnMount:j,select:A,staleTime:_t,suspense:ct,throwOnError:ze,config:Le,connector:Ge,query:He,...Pt}=t;return Pt}function qe(t){return{mutationFn(n){return fe(t,n)},mutationKey:["connect"]}}function De(t){return{mutationFn(n){return he(t,n)},mutationKey:["disconnect"]}}function Fe(t,n={}){return{async queryFn({queryKey:e}){const{address:r,scopeKey:o,...c}=e[1];if(!r)throw new Error("address is required");return await ye(t,{...c,address:r})??null},queryKey:Re(n)}}function Re(t={}){return["balance",We(t)]}function Ne(t){const n=K(()=>({...U(t),queryKeyHashFn:Te})),e=Xt(n);return e.queryKey=U(n).queryKey,e}function Be(t={}){const n=k(t),e=et(be(n)),r=Ie(n,{onChange(o){e.value=o}});return q(()=>r()),tt(e)}function dn(t={}){const n=K(()=>jt(t)),e=k(n),r=Be({config:e}),o=K(()=>{const{address:c,chainId:i=r.value,query:u={}}=n.value,a=Fe(e,{...n.value,chainId:i}),s=!!(c&&(u.enabled??!0));return{...u,...a,enabled:s}});return Ne(o)}function Ue(t={}){const n=k(t),e=et(we(n)),r=Se(n,{onChange(o){e.value=o}});return q(()=>r()),e}function ln(t={}){const{mutation:n}=t,e=k(t),r=qe(e),{mutate:o,mutateAsync:c,...i}=yt({...n,...r}),u=e.subscribe(({status:a})=>a,(a,s)=>{s==="connected"&&a==="disconnected"&&i.reset()});return q(()=>u()),{...i,connect:o,connectAsync:c,connectors:Ue({config:e}).value}}function Ke(t={}){const n=k(t),e=et(It(n)),r=Oe(n,{onChange(o){e.value=o}});return q(()=>r()),tt(e)}function fn(t={}){const{mutation:n}=t,e=k(t),r=Ke({config:e}),o=De(e),{mutate:c,mutateAsync:i,...u}=yt({...n,...o});return{...u,connectors:K(()=>r.value.map(a=>a.connector)),disconnect:c,disconnectAsync:i}}export{Z as C,an as W,en as a,oe as b,tn as c,sn as d,ln as e,fn as f,un as g,on as h,rn as i,nn as s,dn as u,cn as w};
