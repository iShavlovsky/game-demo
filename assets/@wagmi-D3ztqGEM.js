import{c as G,s as Pt,p as At}from"./zustand-YPADddZo.js";import{g as W,S as ct,n as st,U as _,w as Mt,a as kt,R as H,c as lt,p as $t,b as xt,d as Et,m as Tt,r as Wt,C as ft,h as ht,t as qt,f as pt,e as Ft,i as Rt,s as Dt,j as Nt,k as Bt,l as Ut}from"./viem-DtW8Nrxk.js";import{E as Kt}from"./eventemitter3-DVaOc9f-.js";import{c as zt}from"./mipd-CIcDX0W7.js";import{u as U,h as Lt,i as Gt,x as Ht,t as Vt,k as tt,o as q,a as gt,c as K,r as et}from"./@vue-BGm6lEuq.js";import{u as Qt,a as mt}from"./@tanstack-BhKubEP-.js";class Jt{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Kt})}on(n,e){this._emitter.on(n,e)}once(n,e){this._emitter.once(n,e)}off(n,e){this._emitter.off(n,e)}emit(n,...e){const r=e[0];this._emitter.emit(n,{uid:this.uid,...r})}listenerCount(n){return this._emitter.listenerCount(n)}}function Zt(t){return new Jt(t)}function Xt(t,n){return JSON.parse(t,(e,r)=>{let o=r;return(o==null?void 0:o.__type)==="bigint"&&(o=BigInt(o.value)),(o==null?void 0:o.__type)==="Map"&&(o=new Map(o.value)),(n==null?void 0:n(e,o))??o})}function it(t,n){return t.slice(0,n).join(".")||"."}function at(t,n){const{length:e}=t;for(let r=0;r<e;++r)if(t[r]===n)return r+1;return 0}function Yt(t,n){const e=typeof t=="function",r=typeof n=="function",o=[],s=[];return function(u,a){if(typeof a=="object")if(o.length){const c=at(o,this);c===0?o[o.length]=this:(o.splice(c),s.splice(c)),s[s.length]=u;const h=at(o,a);if(h!==0)return r?n.call(this,u,a,it(s,h)):`[ref=${it(s,h)}]`}else o[0]=a,s[0]=u;return e?t.call(this,u,a):a}}function te(t,n,e,r){return JSON.stringify(t,Yt((o,s)=>{let i=s;return typeof i=="bigint"&&(i={__type:"bigint",value:s.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(s.entries())}),(n==null?void 0:n(o,i))??i},r),e??void 0)}function ee(t){const{deserialize:n=Xt,key:e="wagmi",serialize:r=te,storage:o=yt}=t;function s(i){return i instanceof Promise?i.then(u=>u).catch(()=>null):i}return{...o,key:e,async getItem(i,u){const a=o.getItem(`${e}.${i}`),c=await s(a);return c?n(c)??null:u??null},async setItem(i,u){const a=`${e}.${i}`;u===null?await s(o.removeItem(a)):await s(o.setItem(a,r(u)))},async removeItem(i){await s(o.removeItem(`${e}.${i}`))}}}const yt={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function Xe(t){return t}const N="2.10.4",ne=()=>`@wagmi/core@${N}`;var bt=function(t,n,e,r){if(e==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?t!==n||!r:!n.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?r:e==="a"?r.call(t):r?r.value:n.get(t)},z,wt;let T=class J extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return ne()}constructor(n,e={}){var s;super(),z.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const r=e.cause instanceof J?e.cause.details:(s=e.cause)!=null&&s.message?e.cause.message:e.details,o=e.cause instanceof J&&e.cause.docsPath||e.docsPath;this.message=[n||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...o?[`Docs: ${this.docsBaseUrl}${o}.html${e.docsSlug?`#${e.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),e.cause&&(this.cause=e.cause),this.details=r,this.docsPath=o,this.metaMessages=e.metaMessages,this.shortMessage=n}walk(n){return bt(this,z,"m",wt).call(this,this,n)}};z=new WeakSet,wt=function t(n,e){return e!=null&&e(n)?n:n.cause?bt(this,z,"m",t).call(this,n.cause,e):n};class Z extends T{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class re extends T{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class oe extends T{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class ce extends T{constructor({address:n,connector:e}){super(`Account "${n}" not found for connector "${e.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class x extends T{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const se=/(rabby|trustwallet)/,ie={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t!=null&&t.coinbaseWalletExtension?t.coinbaseWalletExtension:B(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return B(t,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const e=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const r of e)if(n[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){var n,e;return(n=t==null?void 0:t.phantom)!=null&&n.ethereum?(e=t.phantom)==null?void 0:e.ethereum:B(t,"isPhantom")}}};nt.type="injected";function nt(t={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:e}=t;function r(){const a=t.target;if(typeof a=="function"){const c=a();if(c)return c}return typeof a=="object"?a:typeof a=="string"?{...ie[a]??{id:a,name:`${a[0].toUpperCase()}${a.slice(1)}`,provider:`is${a[0].toUpperCase()}${a.slice(1)}`}}:{id:"injected",name:"Injected",provider(c){return c==null?void 0:c.ethereum}}}let o,s,i,u;return a=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return se.test(this.id.toLowerCase())},type:nt.type,async setup(){const c=await this.getProvider();c&&t.target&&(i||(i=this.onConnect.bind(this),c.on("connect",i)),o||(o=this.onAccountsChanged.bind(this),c.on("accountsChanged",o)))},async connect({chainId:c,isReconnecting:h}={}){var C,m,O,y,v,S;const l=await this.getProvider();if(!l)throw new x;let g=[];if(h)g=await this.getAccounts().catch(()=>[]);else if(n)try{g=(y=(O=(m=(C=(await l.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:C.caveats)==null?void 0:m[0])==null?void 0:O.value)==null?void 0:y.map(d=>W(d))}catch(I){const d=I;if(d.code===_.code)throw new _(d);if(d.code===H.code)throw d}try{!(g!=null&&g.length)&&!h&&(g=(await l.request({method:"eth_requestAccounts"})).map(p=>W(p))),i&&(l.removeListener("connect",i),i=void 0),o||(o=this.onAccountsChanged.bind(this),l.on("accountsChanged",o)),s||(s=this.onChainChanged.bind(this),l.on("chainChanged",s)),u||(u=this.onDisconnect.bind(this),l.on("disconnect",u));let I=await this.getChainId();if(c&&I!==c){const d=await this.switchChain({chainId:c}).catch(p=>{if(p.code===_.code)throw p;return{id:I}});I=(d==null?void 0:d.id)??I}return n&&await((v=a.storage)==null?void 0:v.removeItem(`${this.id}.disconnected`)),t.target||await((S=a.storage)==null?void 0:S.setItem("injected.connected",!0)),{accounts:g,chainId:I}}catch(I){const d=I;throw d.code===_.code?new _(d):d.code===H.code?new H(d):d}},async disconnect(){var h,l;const c=await this.getProvider();if(!c)throw new x;s&&(c.removeListener("chainChanged",s),s=void 0),u&&(c.removeListener("disconnect",u),u=void 0),i||(i=this.onConnect.bind(this),c.on("connect",i));try{await c.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((h=a.storage)==null?void 0:h.setItem(`${this.id}.disconnected`,!0)),t.target||await((l=a.storage)==null?void 0:l.removeItem("injected.connected"))},async getAccounts(){const c=await this.getProvider();if(!c)throw new x;return(await c.request({method:"eth_accounts"})).map(l=>W(l))},async getChainId(){const c=await this.getProvider();if(!c)throw new x;const h=await c.request({method:"eth_chainId"});return Number(h)},async getProvider(){if(typeof window>"u")return;let c;const h=r();return typeof h.provider=="function"?c=h.provider(window):typeof h.provider=="string"?c=B(window,h.provider):c=h.provider,c&&!c.removeListener&&("off"in c&&typeof c.off=="function"?c.removeListener=c.off:c.removeListener=()=>{}),c},async isAuthorized(){var c,h;try{if(n&&await((c=a.storage)==null?void 0:c.getItem(`${this.id}.disconnected`))||!t.target&&!await((h=a.storage)==null?void 0:h.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(e!==void 0&&e!==!1){const m=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",m),!!await this.getProvider()),O=typeof e=="number"?e:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(v=>window.addEventListener("ethereum#initialized",()=>v(m()),{once:!0}))]:[],new Promise(v=>setTimeout(()=>v(m()),O))]))return!0}throw new x}return!!(await Mt(()=>kt(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:h}){var C,m,O,y;const l=await this.getProvider();if(!l)throw new x;const g=a.chains.find(v=>v.id===h);if(!g)throw new ct(new Z);try{return await Promise.all([l.request({method:"wallet_switchEthereumChain",params:[{chainId:st(h)}]}).then(async()=>{await this.getChainId()===h&&a.emitter.emit("change",{chainId:h})}),new Promise(v=>a.emitter.once("change",({chainId:S})=>{S===h&&v()}))]),g}catch(v){const S=v;if(S.code===4902||((m=(C=S==null?void 0:S.data)==null?void 0:C.originalError)==null?void 0:m.code)===4902)try{const{default:I,...d}=g.blockExplorers??{};let p;c!=null&&c.blockExplorerUrls?p=c.blockExplorerUrls:I&&(p=[I.url,...Object.values(d).map($=>$.url)]);let f;(O=c==null?void 0:c.rpcUrls)!=null&&O.length?f=c.rpcUrls:f=[((y=g.rpcUrls.default)==null?void 0:y.http[0])??""];const b={blockExplorerUrls:p,chainId:st(h),chainName:(c==null?void 0:c.chainName)??g.name,iconUrls:c==null?void 0:c.iconUrls,nativeCurrency:(c==null?void 0:c.nativeCurrency)??g.nativeCurrency,rpcUrls:f};if(await l.request({method:"wallet_addEthereumChain",params:[b]}),await this.getChainId()!==h)throw new _(new Error("User rejected switch after adding network."));return g}catch(I){throw new _(I)}throw S.code===_.code?new _(S):new ct(S)}},async onAccountsChanged(c){var h;if(c.length===0)this.onDisconnect();else if(a.emitter.listenerCount("connect")){const l=(await this.getChainId()).toString();this.onConnect({chainId:l}),n&&await((h=a.storage)==null?void 0:h.removeItem(`${this.id}.disconnected`))}else a.emitter.emit("change",{accounts:c.map(l=>W(l))})},onChainChanged(c){const h=Number(c);a.emitter.emit("change",{chainId:h})},async onConnect(c){const h=await this.getAccounts();if(h.length===0)return;const l=Number(c.chainId);a.emitter.emit("connect",{accounts:h,chainId:l});const g=await this.getProvider();g&&(i&&(g.removeListener("connect",i),i=void 0),o||(o=this.onAccountsChanged.bind(this),g.on("accountsChanged",o)),s||(s=this.onChainChanged.bind(this),g.on("chainChanged",s)),u||(u=this.onDisconnect.bind(this),g.on("disconnect",u)))},async onDisconnect(c){const h=await this.getProvider();c&&c.code===1013&&h&&(await this.getAccounts()).length||(a.emitter.emit("disconnect"),h&&(s&&(h.removeListener("chainChanged",s),s=void 0),u&&(h.removeListener("disconnect",u),u=void 0),i||(i=this.onConnect.bind(this),h.on("connect",i))))}})}function B(t,n){function e(o){return typeof n=="function"?n(o):typeof n=="string"?o[n]:!0}const r=t.ethereum;if(r!=null&&r.providers)return r.providers.find(o=>e(o));if(r&&e(r))return r}const X=256;let F=X,R;function ae(t=11){if(!R||F+t>X*2){R="",F=0;for(let n=0;n<X;n++)R+=(256+Math.random()*256|0).toString(16).substring(1)}return R.substring(F,F+++t)}function Ye(t){const{multiInjectedProviderDiscovery:n=!0,storage:e=ee({storage:typeof window<"u"&&window.localStorage?window.localStorage:yt}),syncConnectedChain:r=!0,ssr:o,...s}=t,i=typeof window<"u"&&n?zt():void 0,u=G(()=>s.chains),a=G(()=>[...s.connectors??[],...o?[]:(i==null?void 0:i.getProviders().map(h))??[]].map(c));function c(d){var b;const p=Zt(ae()),f={...d({emitter:p,chains:u.getState(),storage:e}),emitter:p,uid:p.uid};return p.on("connect",S),(b=f.setup)==null||b.call(f),f}function h(d){const{info:p}=d,f=d.provider;return nt({target:{...p,id:p.rdns,provider:f}})}const l=new Map;function g(d={}){const p=d.chainId??y.getState().chainId,f=u.getState().find(w=>w.id===p);if(d.chainId&&!f)throw new Z;{const w=l.get(y.getState().chainId);if(w&&!f)return w;if(!f)throw new Z}{const w=l.get(p);if(w)return w}let b;if(s.client)b=s.client({chain:f});else{const w=f.id,$=u.getState().map(j=>j.id),P={},L=Object.entries(s);for(const[j,M]of L)if(!(j==="chains"||j==="client"||j==="connectors"||j==="transports"))if(typeof M=="object")if(w in M)P[j]=M[w];else{if($.some(ot=>ot in M))continue;P[j]=M}else P[j]=M;b=lt({...P,chain:f,batch:P.batch??{multicall:!0},transport:j=>s.transports[w]({...j,connectors:a})})}return l.set(p,b),b}function C(){return{chainId:u.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let m;const O="0.0.0-canary-";N.startsWith(O)?m=parseInt(N.replace(O,"")):m=parseInt(N.split(".")[0]??"0");const y=G(Pt(e?At(C,{migrate(d,p){if(p===m)return d;const f=C(),b=d&&typeof d=="object"&&"chainId"in d&&typeof d.chainId=="number"?d.chainId:f.chainId;return{...f,chainId:b}},name:"store",partialize(d){return{connections:{__type:"Map",value:Array.from(d.connections.entries()).map(([p,f])=>{const{id:b,name:w,type:$,uid:P}=f.connector;return[p,{...f,connector:{id:b,name:w,type:$,uid:P}}]})},chainId:d.chainId,current:d.current}},skipHydration:o,storage:e,version:m}):C));r&&y.subscribe(({connections:d,current:p})=>{var f;return p?(f=d.get(p))==null?void 0:f.chainId:void 0},d=>{if(u.getState().some(f=>f.id===d))return y.setState(f=>({...f,chainId:d??f.chainId}))}),i==null||i.subscribe(d=>{const p=new Map;for(const b of a.getState())p.set(b.id,!0);const f=[];for(const b of d){const w=c(h(b));p.has(w.id)||f.push(w)}e&&!y.persist.hasHydrated()||a.setState(b=>[...b,...f],!0)});function v(d){y.setState(p=>{const f=p.connections.get(d.uid);return f?{...p,connections:new Map(p.connections).set(d.uid,{accounts:d.accounts??f.accounts,chainId:d.chainId??f.chainId,connector:f.connector})}:p})}function S(d){y.getState().status==="connecting"||y.getState().status==="reconnecting"||y.setState(p=>{const f=a.getState().find(b=>b.uid===d.uid);return f?(f.emitter.listenerCount("connect")&&f.emitter.off("connect",v),f.emitter.listenerCount("change")||f.emitter.on("change",v),f.emitter.listenerCount("disconnect")||f.emitter.on("disconnect",I),{...p,connections:new Map(p.connections).set(d.uid,{accounts:d.accounts,chainId:d.chainId,connector:f}),current:d.uid,status:"connected"}):p})}function I(d){y.setState(p=>{const f=p.connections.get(d.uid);if(f){const w=f.connector;w.emitter.listenerCount("change")&&f.connector.emitter.off("change",v),w.emitter.listenerCount("disconnect")&&f.connector.emitter.off("disconnect",I),w.emitter.listenerCount("connect")||f.connector.emitter.on("connect",S)}if(p.connections.delete(d.uid),p.connections.size===0)return{...p,connections:new Map,current:null,status:"disconnected"};const b=p.connections.values().next().value;return{...p,connections:new Map(p.connections),current:b.connector.uid}})}return{get chains(){return u.getState()},get connectors(){return a.getState()},storage:e,getClient:g,get state(){return y.getState()},setState(d){let p;typeof d=="function"?p=d(y.getState()):p=d;const f=C();typeof p!="object"&&(p=f),Object.keys(f).some(w=>!(w in p))&&(p=f),y.setState(p,!0)},subscribe(d,p,f){return y.subscribe(d,p,f?{...f,fireImmediately:f.emitImmediately}:void 0)},_internal:{mipd:i,store:y,ssr:!!o,syncConnectedChain:r,transports:s.transports,chains:{setState(d){const p=typeof d=="function"?d(u.getState()):d;if(p.length!==0)return u.setState(p,!0)},subscribe(d){return u.subscribe(d)}},connectors:{providerDetailToConnector:h,setup:c,setState(d){return a.setState(typeof d=="function"?d(a.getState()):d,!0)},subscribe(d){return a.subscribe(d)}},events:{change:v,connect:S,disconnect:I}}}}function A(t,n,e){const r=t[n.name];if(typeof r=="function")return r;const o=t[e];return typeof o=="function"?o:s=>n(t,s)}async function ue(t,n){var r;let e;if(typeof n.connector=="function"?e=t._internal.connectors.setup(n.connector):e=n.connector,e.uid===t.state.current)throw new re;try{t.setState(i=>({...i,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});const o=await e.connect({chainId:n.chainId}),s=o.accounts;return e.emitter.off("connect",t._internal.events.connect),e.emitter.on("change",t._internal.events.change),e.emitter.on("disconnect",t._internal.events.disconnect),await((r=t.storage)==null?void 0:r.setItem("recentConnectorId",e.id)),t.setState(i=>({...i,connections:new Map(i.connections).set(e.uid,{accounts:s,chainId:o.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:s,chainId:o.chainId}}catch(o){throw t.setState(s=>({...s,status:s.current?"connected":"disconnected"})),o}}async function de(t,n={}){var o,s;let e;if(n.connector)e=n.connector;else{const{connections:i,current:u}=t.state,a=i.get(u);e=a==null?void 0:a.connector}const r=t.state.connections;e&&(await e.disconnect(),e.emitter.off("change",t._internal.events.change),e.emitter.off("disconnect",t._internal.events.disconnect),e.emitter.on("connect",t._internal.events.connect),r.delete(e.uid)),t.setState(i=>{if(r.size===0)return{...i,connections:new Map,current:null,status:"disconnected"};const u=r.values().next().value;return{...i,connections:new Map(r),current:u.connector.uid}});{const i=t.state.current;if(!i)return;const u=(o=t.state.connections.get(i))==null?void 0:o.connector;if(!u)return;await((s=t.storage)==null?void 0:s.setItem("recentConnectorId",u.id))}}async function le(t,n={}){let e;if(n.connector){const{connector:a}=n,[c,h]=await Promise.all([a.getAccounts(),a.getChainId()]);e={accounts:c,chainId:h,connector:a}}else e=t.state.connections.get(t.state.current);if(!e)throw new oe;const r=n.chainId??e.chainId,o=e.connector;if(o.getClient)return o.getClient({chainId:r});const s=$t(n.account??e.accounts[0]);s.address=W(s.address);const i=t.chains.find(a=>a.id===r),u=await e.connector.getProvider({chainId:r});if(n.account&&!e.accounts.some(a=>a.toLowerCase()===s.address.toLowerCase()))throw new ce({address:s.address,connector:o});return lt({account:s,chain:i,name:"Connector Client",transport:a=>xt(u)({...a,retryCount:0})})}function Ct(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(Et[t])}function rt(t){const n=t.state.current,e=t.state.connections.get(n),r=e==null?void 0:e.accounts,o=r==null?void 0:r[0],s=t.chains.find(u=>u.id===(e==null?void 0:e.chainId)),i=t.state.status;switch(i){case"connected":return{address:o,addresses:r,chain:s,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:i};case"reconnecting":return{address:o,addresses:r,chain:s,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!!o,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:i};case"connecting":return{address:o,addresses:r,chain:s,chainId:e==null?void 0:e.chainId,connector:e==null?void 0:e.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:i};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:i}}}async function fe(t,n){const{allowFailure:e=!0,chainId:r,contracts:o,...s}=n,i=t.getClient({chainId:r});return A(i,Tt,"multicall")({allowFailure:e,contracts:o,...s})}function he(t,n){const{chainId:e,...r}=n,o=t.getClient({chainId:e});return A(o,Wt,"readContract")(r)}async function pe(t,n){const{allowFailure:e=!0,blockNumber:r,blockTag:o,...s}=n,i=n.contracts;try{const u=i.reduce((l,g,C)=>{const m=g.chainId??t.state.chainId;return{...l,[m]:[...l[m]||[],{contract:g,index:C}]}},{}),a=()=>Object.entries(u).map(([l,g])=>fe(t,{...s,allowFailure:e,blockNumber:r,blockTag:o,chainId:parseInt(l),contracts:g.map(({contract:C})=>C)})),c=(await Promise.all(a())).flat(),h=Object.values(u).flatMap(l=>l.map(({index:g})=>g));return c.reduce((l,g,C)=>(l&&(l[h[C]]=g),l),[])}catch(u){if(u instanceof ft)throw u;const a=()=>i.map(c=>he(t,{...c,blockNumber:r,blockTag:o}));return e?(await Promise.allSettled(a())).map(c=>c.status==="fulfilled"?{result:c.value,status:"success"}:{error:c.reason,result:void 0,status:"failure"}):await Promise.all(a())}}async function ge(t,n){const{address:e,blockNumber:r,blockTag:o,chainId:s,token:i,unit:u="ether"}=n;if(i)try{return ut(t,{balanceAddress:e,chainId:s,symbolType:"string",tokenAddress:i})}catch(g){if(g instanceof ft){const C=await ut(t,{balanceAddress:e,chainId:s,symbolType:"bytes32",tokenAddress:i}),m=ht(qt(C.symbol,{dir:"right"}));return{...C,symbol:m}}throw g}const a=t.getClient({chainId:s}),h=await A(a,Ft,"getBalance")(r?{address:e,blockNumber:r}:{address:e,blockTag:o}),l=t.chains.find(g=>g.id===s)??a.chain;return{decimals:l.nativeCurrency.decimals,formatted:pt(h,Ct(u)),symbol:l.nativeCurrency.symbol,value:h}}async function ut(t,n){const{balanceAddress:e,chainId:r,symbolType:o,tokenAddress:s,unit:i}=n,u={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:o}]}],address:s},[a,c,h]=await pe(t,{allowFailure:!1,contracts:[{...u,functionName:"balanceOf",args:[e],chainId:r},{...u,functionName:"decimals",chainId:r},{...u,functionName:"symbol",chainId:r}]}),l=pt(a??"0",Ct(i??c));return{decimals:c,formatted:l,symbol:h,value:a}}function me(t){return t.state.chainId}function E(t,n){if(t===n)return!0;if(t&&n&&typeof t=="object"&&typeof n=="object"){if(t.constructor!==n.constructor)return!1;let e,r;if(Array.isArray(t)&&Array.isArray(n)){if(e=t.length,e!==n.length)return!1;for(r=e;r--!==0;)if(!E(t[r],n[r]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();const o=Object.keys(t);if(e=o.length,e!==Object.keys(n).length)return!1;for(r=e;r--!==0;)if(!Object.prototype.hasOwnProperty.call(n,o[r]))return!1;for(r=e;r--!==0;){const s=o[r];if(s&&!E(t[s],n[s]))return!1}return!0}return t!==t&&n!==n}let D=[];function vt(t){const n=[...t.state.connections.values()];return t.state.status==="reconnecting"||E(D,n)?D:(D=n,n)}let V=[];function ye(t){const n=t.connectors;return E(V,n)?V:(V=n,n)}let Q=!1;async function be(t,n={}){var c,h;if(Q)return[];Q=!0,t.setState(l=>({...l,status:l.current?"reconnecting":"connecting"}));const e=[];if((c=n.connectors)!=null&&c.length)for(const l of n.connectors){let g;typeof l=="function"?g=t._internal.connectors.setup(l):g=l,e.push(g)}else e.push(...t.connectors);let r;try{r=await((h=t.storage)==null?void 0:h.getItem("recentConnectorId"))}catch{}const o={};for(const[,l]of t.state.connections)o[l.connector.id]=1;r&&(o[r]=0);const s=Object.keys(o).length>0?[...e].sort((l,g)=>(o[l.id]??10)-(o[g.id]??10)):e;let i=!1;const u=[],a=[];for(const l of s){const g=await l.getProvider().catch(()=>{});if(!g||a.some(O=>O===g)||!await l.isAuthorized())continue;const m=await l.connect({isReconnecting:!0}).catch(()=>null);m&&(l.emitter.off("connect",t._internal.events.connect),l.emitter.on("change",t._internal.events.change),l.emitter.on("disconnect",t._internal.events.disconnect),t.setState(O=>{const y=new Map(i?O.connections:new Map).set(l.uid,{accounts:m.accounts,chainId:m.chainId,connector:l});return{...O,current:i?O.current:l.uid,connections:y}}),u.push({accounts:m.accounts,chainId:m.chainId,connector:l}),a.push(g),i=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(i?t.setState(l=>({...l,status:"connected"})):t.setState(l=>({...l,connections:new Map,current:null,status:"disconnected"}))),Q=!1,u}async function tn(t,n){const{account:e,chainId:r,connector:o,gas:s,...i}=n;let u;typeof e=="object"&&e.type==="local"?u=t.getClient({chainId:r}):u=await le(t,{account:e,chainId:r,connector:o});const{connector:a}=rt(t),c=await(async()=>{var g;if(!(!("data"in n)||!n.data)&&!((g=o??a)!=null&&g.supportsSimulation)&&s!==null)return s===void 0?A(u,Rt,"estimateGas")({...i,account:e,chain:r?{id:r}:null}):s})();return await A(u,Dt,"sendTransaction")({...i,...e?{account:e}:{},gas:c,chain:r?{id:r}:null})}function we(t,n){const{onChange:e}=n;return t.subscribe(()=>rt(t),e,{equalityFn(r,o){const{connector:s,...i}=r,{connector:u,...a}=o;return E(i,a)&&(s==null?void 0:s.id)===(u==null?void 0:u.id)&&(s==null?void 0:s.uid)===(u==null?void 0:u.uid)}})}function Ce(t,n){const{onChange:e}=n;return t.subscribe(r=>r.chainId,e)}function ve(t,n){const{onChange:e}=n;return t.subscribe(()=>vt(t),e,{equalityFn:E})}function Ie(t,n){const{onChange:e}=n;return t._internal.connectors.subscribe((r,o)=>{e(Object.values(r),o)})}async function en(t,n){const{chainId:e,timeout:r=0,...o}=n,s=t.getClient({chainId:e}),u=await A(s,Nt,"waitForTransactionReceipt")({...o,timeout:r});if(u.status==="reverted"){const c=await A(s,Bt,"getTransaction")({hash:u.transactionHash}),l=await A(s,Ut,"call")({...c,gasPrice:c.type!=="eip1559"?c.gasPrice:void 0,maxFeePerGas:c.type==="eip1559"?c.maxFeePerGas:void 0,maxPriorityFeePerGas:c.type==="eip1559"?c.maxPriorityFeePerGas:void 0}),g=l!=null&&l.data?ht(`0x${l.data.substring(138)}`):"unknown reason";throw new Error(g)}return{...u,chainId:s.chain.id}}function Oe(t,n){const{initialState:e,reconnectOnMount:r}=n;return e&&!t._internal.store.persist.hasHydrated()&&t.setState({...e,connections:r?e.connections:new Map,status:r?"reconnecting":"disconnected"}),{async onMount(){var o;if(t._internal.ssr){await t._internal.store.persist.rehydrate();const s=(o=t._internal.mipd)==null?void 0:o.getProviders().map(t._internal.connectors.providerDetailToConnector).map(t._internal.connectors.setup);t._internal.connectors.setState(i=>[...i,...s??[]])}r?be(t):t.storage&&t.setState(s=>({...s,connections:new Map}))}}}const nn={getItem(t){return typeof window>"u"?null:Se(document.cookie,t)??null},setItem(t,n){typeof window>"u"||(document.cookie=`${t}=${n}`)},removeItem(t){typeof window>"u"||(document.cookie=`${t}=;max-age=-1`)}};function Se(t,n){const e=t.split("; ").find(r=>r.startsWith(`${n}=`));if(e)return e.substring(n.length+1)}const It=Symbol(),rn={install(t,n){const{config:e,reconnectOnMount:r=!0}=n;t.provide(It,e);const{onMount:o}=Oe(e,{...n,reconnectOnMount:r});o()}},je="0.0.10",_e=()=>`@wagmi/vue@${je}`;class Ot extends T{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return _e()}}class Pe extends Ot{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class Ae extends Ot{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function Me(t,n){Object.keys(t).forEach(e=>{t[e]=n[e]})}function k(t={}){const n=U(t);if(n.config)return n.config;if(!Lt())throw new Ae;const e=Gt(It);if(!e)throw new Pe;return e}function on(t={}){const n=k(t),e=Ht(rt(n)),r=we(n,{onChange(o){Me(e,o)}});return q(()=>r()),Vt(tt(e))}function Y(t,n){if(n){const e=n(t);if(e===void 0&&gt(t)||e!==void 0)return e}if(Array.isArray(t))return t.map(e=>Y(e,n));if(typeof t=="object"&&ke(t)){const e=Object.entries(t).map(([r,o])=>[r,Y(o,n)]);return Object.fromEntries(e)}return t}function St(t){return Y(t,n=>{if(gt(n))return St(U(n))})}function ke(t){if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const n=Object.getPrototypeOf(t);return n===null||n===Object.prototype}function $e(t){return JSON.stringify(t,(n,e)=>xe(e)?Object.keys(e).sort().reduce((r,o)=>(r[o]=e[o],r),{}):typeof e=="bigint"?e.toString():e)}function xe(t){if(!dt(t))return!1;const n=t.constructor;if(typeof n>"u")return!0;const e=n.prototype;return!(!dt(e)||!e.hasOwnProperty("isPrototypeOf"))}function dt(t){return Object.prototype.toString.call(t)==="[object Object]"}function Ee(t){const{_defaulted:n,behavior:e,gcTime:r,initialData:o,initialDataUpdatedAt:s,maxPages:i,meta:u,networkMode:a,queryFn:c,queryHash:h,queryKey:l,queryKeyHashFn:g,retry:C,retryDelay:m,structuralSharing:O,getPreviousPageParam:y,getNextPageParam:v,initialPageParam:S,_optimisticResults:I,enabled:d,notifyOnChangeProps:p,placeholderData:f,refetchInterval:b,refetchIntervalInBackground:w,refetchOnMount:$,refetchOnReconnect:P,refetchOnWindowFocus:L,retryOnMount:j,select:M,staleTime:jt,suspense:ot,throwOnError:Ue,config:Ke,connector:ze,query:Le,..._t}=t;return _t}function Te(t){return{mutationFn(n){return ue(t,n)},mutationKey:["connect"]}}function We(t){return{mutationFn(n){return de(t,n)},mutationKey:["disconnect"]}}function qe(t,n={}){return{async queryFn({queryKey:e}){const{address:r,scopeKey:o,...s}=e[1];if(!r)throw new Error("address is required");return await ge(t,{...s,address:r})??null},queryKey:Fe(n)}}function Fe(t={}){return["balance",Ee(t)]}function Re(t){const n=K(()=>({...U(t),queryKeyHashFn:$e})),e=Qt(n);return e.queryKey=U(n).queryKey,e}function De(t={}){const n=k(t),e=et(me(n)),r=Ce(n,{onChange(o){e.value=o}});return q(()=>r()),tt(e)}function cn(t={}){const n=K(()=>St(t)),e=k(n),r=De({config:e}),o=K(()=>{const{address:s,chainId:i=r.value,query:u={}}=n.value,a=qe(e,{...n.value,chainId:i}),c=!!(s&&(u.enabled??!0));return{...u,...a,enabled:c}});return Re(o)}function Ne(t={}){const n=k(t),e=et(ye(n)),r=Ie(n,{onChange(o){e.value=o}});return q(()=>r()),e}function sn(t={}){const{mutation:n}=t,e=k(t),r=Te(e),{mutate:o,mutateAsync:s,...i}=mt({...n,...r}),u=e.subscribe(({status:a})=>a,(a,c)=>{c==="connected"&&a==="disconnected"&&i.reset()});return q(()=>u()),{...i,connect:o,connectAsync:s,connectors:Ne({config:e}).value}}function Be(t={}){const n=k(t),e=et(vt(n)),r=ve(n,{onChange(o){e.value=o}});return q(()=>r()),tt(e)}function an(t={}){const{mutation:n}=t,e=k(t),r=Be({config:e}),o=We(e),{mutate:s,mutateAsync:i,...u}=mt({...n,...o});return{...u,connectors:K(()=>r.value.map(a=>a.connector)),disconnect:s,disconnectAsync:i}}export{Z as C,rn as W,Ye as a,ee as b,Xe as c,nn as d,sn as e,an as f,on as g,tn as s,cn as u,en as w};
