const I={},w=u=>(a,s,n)=>{const c=n.subscribe;return n.subscribe=(m,d,l)=>{let i=m;if(d){const f=(l==null?void 0:l.equalityFn)||Object.is;let h=m(n.getState());i=y=>{const g=m(y);if(!f(h,g)){const b=h;d(h=g,b)}},l!=null&&l.fireImmediately&&d(h,h)}return c(i)},u(a,s,n)},z=w;function E(u,a){let s;try{s=u()}catch{return}return{getItem:c=>{var e;const m=l=>l===null?null:JSON.parse(l,void 0),d=(e=s.getItem(c))!=null?e:null;return d instanceof Promise?d.then(m):m(d)},setItem:(c,e)=>s.setItem(c,JSON.stringify(e,void 0)),removeItem:c=>s.removeItem(c)}}const p=u=>a=>{try{const s=u(a);return s instanceof Promise?s:{then(n){return p(n)(s)},catch(n){return this}}}catch(s){return{then(n){return this},catch(n){return p(n)(s)}}}},H=(u,a)=>(s,n,c)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,v)=>({...v,...r}),...a},m=!1;const d=new Set,l=new Set;let i;try{i=e.getStorage()}catch{}if(!i)return u((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},n,c);const f=p(e.serialize),h=()=>{const r=e.partialize({...n()});let v;const t=f({state:r,version:e.version}).then(S=>i.setItem(e.name,S)).catch(S=>{v=S});if(v)throw v;return t},y=c.setState;c.setState=(r,v)=>{y(r,v),h()};const g=u((...r)=>{s(...r),h()},n,c);let b;const o=()=>{var r;if(!i)return;m=!1,d.forEach(t=>t(n()));const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,n()))||void 0;return p(i.getItem.bind(i))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var S;return b=e.merge(t,(S=n())!=null?S:g),s(b,!0),h()}).then(()=>{v==null||v(b,void 0),m=!0,l.forEach(t=>t(b))}).catch(t=>{v==null||v(void 0,t)})};return c.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(i=r.getStorage())},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>o(),hasHydrated:()=>m,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(l.add(r),()=>{l.delete(r)})},o(),b||g},R=(u,a)=>(s,n,c)=>{let e={storage:E(()=>localStorage),partialize:o=>o,version:0,merge:(o,r)=>({...r,...o}),...a},m=!1;const d=new Set,l=new Set;let i=e.storage;if(!i)return u((...o)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...o)},n,c);const f=()=>{const o=e.partialize({...n()});return i.setItem(e.name,{state:o,version:e.version})},h=c.setState;c.setState=(o,r)=>{h(o,r),f()};const y=u((...o)=>{s(...o),f()},n,c);let g;const b=()=>{var o,r;if(!i)return;m=!1,d.forEach(t=>{var S;return t((S=n())!=null?S:y)});const v=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(o=n())!=null?o:y))||void 0;return p(i.getItem.bind(i))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var S;return g=e.merge(t,(S=n())!=null?S:y),s(g,!0),f()}).then(()=>{v==null||v(g,void 0),g=n(),m=!0,l.forEach(t=>t(g))}).catch(t=>{v==null||v(void 0,t)})};return c.persist={setOptions:o=>{e={...e,...o},o.storage&&(i=o.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>m,onHydrate:o=>(d.add(o),()=>{d.delete(o)}),onFinishHydration:o=>(l.add(o),()=>{l.delete(o)})},e.skipHydration||b(),g||y},F=(u,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?((I?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),H(u,a)):R(u,a),J=F,j={},_=u=>{let a;const s=new Set,n=(l,i)=>{const f=typeof l=="function"?l(a):l;if(!Object.is(f,a)){const h=a;a=i??typeof f!="object"?f:Object.assign({},a,f),s.forEach(y=>y(a,h))}},c=()=>a,d={setState:n,getState:c,subscribe:l=>(s.add(l),()=>s.delete(l)),destroy:()=>{(j?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),s.clear()}};return a=u(n,c,d),d},N=u=>u?_(u):_;export{N as c,J as p,z as s};
