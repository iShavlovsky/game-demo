import{c as L,s as je,p as _e}from"./zustand-YPADddZo.js";import{g as E,S as oe,n as ce,U as _,w as Pe,a as Me,R as V,c as Ae,b as ke,m as $e,r as We,C as de,h as qe,t as Ee,f as le,d as xe}from"./viem-BkIBHPko.js";import{E as De}from"./eventemitter3-DVaOc9f-.js";import{c as Be}from"./mipd-CIcDX0W7.js";import{u as N,h as Re,i as Ue,x as Ne,o as q,t as Te,k as Y,a as fe,c as T,r as ee}from"./@vue-BGm6lEuq.js";import{u as Fe,a as he}from"./@tanstack-BhKubEP-.js";class Ke{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new De})}on(n,t){this._emitter.on(n,t)}once(n,t){this._emitter.once(n,t)}off(n,t){this._emitter.off(n,t)}emit(n,...t){const r=t[0];this._emitter.emit(n,{uid:this.uid,...r})}listenerCount(n){return this._emitter.listenerCount(n)}}function ze(e){return new Ke(e)}function Le(e,n){return JSON.parse(e,(t,r)=>{let o=r;return(o==null?void 0:o.__type)==="bigint"&&(o=BigInt(o.value)),(o==null?void 0:o.__type)==="Map"&&(o=new Map(o.value)),(n==null?void 0:n(t,o))??o})}function ie(e,n){return e.slice(0,n).join(".")||"."}function se(e,n){const{length:t}=e;for(let r=0;r<t;++r)if(e[r]===n)return r+1;return 0}function Ve(e,n){const t=typeof e=="function",r=typeof n=="function",o=[],i=[];return function(d,u){if(typeof u=="object")if(o.length){const c=se(o,this);c===0?o[o.length]=this:(o.splice(c),i.splice(c)),i[i.length]=d;const p=se(o,u);if(p!==0)return r?n.call(this,d,u,ie(i,p)):`[ref=${ie(i,p)}]`}else o[0]=u,i[0]=d;return t?e.call(this,d,u):u}}function He(e,n,t,r){return JSON.stringify(e,Ve((o,i)=>{let s=i;return typeof s=="bigint"&&(s={__type:"bigint",value:i.toString()}),s instanceof Map&&(s={__type:"Map",value:Array.from(i.entries())}),(n==null?void 0:n(o,s))??s},r),t??void 0)}function Qe(e){const{deserialize:n=Le,key:t="wagmi",serialize:r=He,storage:o=pe}=e;function i(s){return s instanceof Promise?s.then(d=>d).catch(()=>null):s}return{...o,key:t,async getItem(s,d){const u=o.getItem(`${t}.${s}`),c=await i(u);return c?n(c)??null:d??null},async setItem(s,d){const u=`${t}.${s}`;d===null?await i(o.removeItem(u)):await i(o.setItem(u,r(d)))},async removeItem(s){await i(o.removeItem(`${t}.${s}`))}}}const pe={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function Ft(e){return e}const R="2.10.4",Je=()=>`@wagmi/core@${R}`;var ge=function(e,n,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(e):r?r.value:n.get(e)},F,me;let K=class J extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return Je()}constructor(n,t={}){var i;super(),F.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const r=t.cause instanceof J?t.cause.details:(i=t.cause)!=null&&i.message?t.cause.message:t.details,o=t.cause instanceof J&&t.cause.docsPath||t.docsPath;this.message=[n||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...o?[`Docs: ${this.docsBaseUrl}${o}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=o,this.metaMessages=t.metaMessages,this.shortMessage=n}walk(n){return ge(this,F,"m",me).call(this,this,n)}};F=new WeakSet,me=function e(n,t){return t!=null&&t(n)?n:n.cause?ge(this,F,"m",e).call(this,n.cause,t):n};class G extends K{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class Ge extends K{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class $ extends K{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}const Ze=/(rabby|trustwallet)/,Xe={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(e){return e!=null&&e.coinbaseWalletExtension?e.coinbaseWalletExtension:U(e,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(e){return U(e,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;const t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const r of t)if(n[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(e){var n,t;return(n=e==null?void 0:e.phantom)!=null&&n.ethereum?(t=e.phantom)==null?void 0:t.ethereum:U(e,"isPhantom")}}};te.type="injected";function te(e={}){const{shimDisconnect:n=!0,unstable_shimAsyncInject:t}=e;function r(){const u=e.target;if(typeof u=="function"){const c=u();if(c)return c}return typeof u=="object"?u:typeof u=="string"?{...Xe[u]??{id:u,name:`${u[0].toUpperCase()}${u.slice(1)}`,provider:`is${u[0].toUpperCase()}${u.slice(1)}`}}:{id:"injected",name:"Injected",provider(c){return c==null?void 0:c.ethereum}}}let o,i,s,d;return u=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return Ze.test(this.id.toLowerCase())},type:te.type,async setup(){const c=await this.getProvider();c&&e.target&&(s||(s=this.onConnect.bind(this),c.on("connect",s)),o||(o=this.onAccountsChanged.bind(this),c.on("accountsChanged",o)))},async connect({chainId:c,isReconnecting:p}={}){var v,m,O,y,I,S;const l=await this.getProvider();if(!l)throw new $;let g=[];if(p)g=await this.getAccounts().catch(()=>[]);else if(n)try{g=(y=(O=(m=(v=(await l.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:v.caveats)==null?void 0:m[0])==null?void 0:O.value)==null?void 0:y.map(a=>E(a))}catch(C){const a=C;if(a.code===_.code)throw new _(a);if(a.code===V.code)throw a}try{!(g!=null&&g.length)&&!p&&(g=(await l.request({method:"eth_requestAccounts"})).map(h=>E(h))),s&&(l.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),l.on("accountsChanged",o)),i||(i=this.onChainChanged.bind(this),l.on("chainChanged",i)),d||(d=this.onDisconnect.bind(this),l.on("disconnect",d));let C=await this.getChainId();if(c&&C!==c){const a=await this.switchChain({chainId:c}).catch(h=>{if(h.code===_.code)throw h;return{id:C}});C=(a==null?void 0:a.id)??C}return n&&await((I=u.storage)==null?void 0:I.removeItem(`${this.id}.disconnected`)),e.target||await((S=u.storage)==null?void 0:S.setItem("injected.connected",!0)),{accounts:g,chainId:C}}catch(C){const a=C;throw a.code===_.code?new _(a):a.code===V.code?new V(a):a}},async disconnect(){var p,l;const c=await this.getProvider();if(!c)throw new $;i&&(c.removeListener("chainChanged",i),i=void 0),d&&(c.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),c.on("connect",s));try{await c.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}n&&await((p=u.storage)==null?void 0:p.setItem(`${this.id}.disconnected`,!0)),e.target||await((l=u.storage)==null?void 0:l.removeItem("injected.connected"))},async getAccounts(){const c=await this.getProvider();if(!c)throw new $;return(await c.request({method:"eth_accounts"})).map(l=>E(l))},async getChainId(){const c=await this.getProvider();if(!c)throw new $;const p=await c.request({method:"eth_chainId"});return Number(p)},async getProvider(){if(typeof window>"u")return;let c;const p=r();return typeof p.provider=="function"?c=p.provider(window):typeof p.provider=="string"?c=U(window,p.provider):c=p.provider,c&&!c.removeListener&&("off"in c&&typeof c.off=="function"?c.removeListener=c.off:c.removeListener=()=>{}),c},async isAuthorized(){var c,p;try{if(n&&await((c=u.storage)==null?void 0:c.getItem(`${this.id}.disconnected`))||!e.target&&!await((p=u.storage)==null?void 0:p.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(t!==void 0&&t!==!1){const m=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",m),!!await this.getProvider()),O=typeof t=="number"?t:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(I=>window.addEventListener("ethereum#initialized",()=>I(m()),{once:!0}))]:[],new Promise(I=>setTimeout(()=>I(m()),O))]))return!0}throw new $}return!!(await Pe(()=>Me(()=>this.getAccounts(),{timeout:100}))).length}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:p}){var v,m,O,y;const l=await this.getProvider();if(!l)throw new $;const g=u.chains.find(I=>I.id===p);if(!g)throw new oe(new G);try{return await Promise.all([l.request({method:"wallet_switchEthereumChain",params:[{chainId:ce(p)}]}).then(async()=>{await this.getChainId()===p&&u.emitter.emit("change",{chainId:p})}),new Promise(I=>u.emitter.once("change",({chainId:S})=>{S===p&&I()}))]),g}catch(I){const S=I;if(S.code===4902||((m=(v=S==null?void 0:S.data)==null?void 0:v.originalError)==null?void 0:m.code)===4902)try{const{default:C,...a}=g.blockExplorers??{};let h;c!=null&&c.blockExplorerUrls?h=c.blockExplorerUrls:C&&(h=[C.url,...Object.values(a).map(k=>k.url)]);let f;(O=c==null?void 0:c.rpcUrls)!=null&&O.length?f=c.rpcUrls:f=[((y=g.rpcUrls.default)==null?void 0:y.http[0])??""];const b={blockExplorerUrls:h,chainId:ce(p),chainName:(c==null?void 0:c.chainName)??g.name,iconUrls:c==null?void 0:c.iconUrls,nativeCurrency:(c==null?void 0:c.nativeCurrency)??g.nativeCurrency,rpcUrls:f};if(await l.request({method:"wallet_addEthereumChain",params:[b]}),await this.getChainId()!==p)throw new _(new Error("User rejected switch after adding network."));return g}catch(C){throw new _(C)}throw S.code===_.code?new _(S):new oe(S)}},async onAccountsChanged(c){var p;if(c.length===0)this.onDisconnect();else if(u.emitter.listenerCount("connect")){const l=(await this.getChainId()).toString();this.onConnect({chainId:l}),n&&await((p=u.storage)==null?void 0:p.removeItem(`${this.id}.disconnected`))}else u.emitter.emit("change",{accounts:c.map(l=>E(l))})},onChainChanged(c){const p=Number(c);u.emitter.emit("change",{chainId:p})},async onConnect(c){const p=await this.getAccounts();if(p.length===0)return;const l=Number(c.chainId);u.emitter.emit("connect",{accounts:p,chainId:l});const g=await this.getProvider();g&&(s&&(g.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),g.on("accountsChanged",o)),i||(i=this.onChainChanged.bind(this),g.on("chainChanged",i)),d||(d=this.onDisconnect.bind(this),g.on("disconnect",d)))},async onDisconnect(c){const p=await this.getProvider();c&&c.code===1013&&p&&(await this.getAccounts()).length||(u.emitter.emit("disconnect"),p&&(i&&(p.removeListener("chainChanged",i),i=void 0),d&&(p.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),p.on("connect",s))))}})}function U(e,n){function t(o){return typeof n=="function"?n(o):typeof n=="string"?o[n]:!0}const r=e.ethereum;if(r!=null&&r.providers)return r.providers.find(o=>t(o));if(r&&t(r))return r}const Z=256;let x=Z,D;function Ye(e=11){if(!D||x+e>Z*2){D="",x=0;for(let n=0;n<Z;n++)D+=(256+Math.random()*256|0).toString(16).substring(1)}return D.substring(x,x+++e)}function Kt(e){const{multiInjectedProviderDiscovery:n=!0,storage:t=Qe({storage:typeof window<"u"&&window.localStorage?window.localStorage:pe}),syncConnectedChain:r=!0,ssr:o,...i}=e,s=typeof window<"u"&&n?Be():void 0,d=L(()=>i.chains),u=L(()=>[...i.connectors??[],...o?[]:(s==null?void 0:s.getProviders().map(p))??[]].map(c));function c(a){var b;const h=ze(Ye()),f={...a({emitter:h,chains:d.getState(),storage:t}),emitter:h,uid:h.uid};return h.on("connect",S),(b=f.setup)==null||b.call(f),f}function p(a){const{info:h}=a,f=a.provider;return te({target:{...h,id:h.rdns,provider:f}})}const l=new Map;function g(a={}){const h=a.chainId??y.getState().chainId,f=d.getState().find(w=>w.id===h);if(a.chainId&&!f)throw new G;{const w=l.get(y.getState().chainId);if(w&&!f)return w;if(!f)throw new G}{const w=l.get(h);if(w)return w}let b;if(i.client)b=i.client({chain:f});else{const w=f.id,k=d.getState().map(j=>j.id),P={},z=Object.entries(i);for(const[j,M]of z)if(!(j==="chains"||j==="client"||j==="connectors"||j==="transports"))if(typeof M=="object")if(w in M)P[j]=M[w];else{if(k.some(re=>re in M))continue;P[j]=M}else P[j]=M;b=Ae({...P,chain:f,batch:P.batch??{multicall:!0},transport:j=>i.transports[w]({...j,connectors:u})})}return l.set(h,b),b}function v(){return{chainId:d.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let m;const O="0.0.0-canary-";R.startsWith(O)?m=parseInt(R.replace(O,"")):m=parseInt(R.split(".")[0]??"0");const y=L(je(t?_e(v,{migrate(a,h){if(h===m)return a;const f=v(),b=a&&typeof a=="object"&&"chainId"in a&&typeof a.chainId=="number"?a.chainId:f.chainId;return{...f,chainId:b}},name:"store",partialize(a){return{connections:{__type:"Map",value:Array.from(a.connections.entries()).map(([h,f])=>{const{id:b,name:w,type:k,uid:P}=f.connector;return[h,{...f,connector:{id:b,name:w,type:k,uid:P}}]})},chainId:a.chainId,current:a.current}},skipHydration:o,storage:t,version:m}):v));r&&y.subscribe(({connections:a,current:h})=>{var f;return h?(f=a.get(h))==null?void 0:f.chainId:void 0},a=>{if(d.getState().some(f=>f.id===a))return y.setState(f=>({...f,chainId:a??f.chainId}))}),s==null||s.subscribe(a=>{const h=new Map;for(const b of u.getState())h.set(b.id,!0);const f=[];for(const b of a){const w=c(p(b));h.has(w.id)||f.push(w)}t&&!y.persist.hasHydrated()||u.setState(b=>[...b,...f],!0)});function I(a){y.setState(h=>{const f=h.connections.get(a.uid);return f?{...h,connections:new Map(h.connections).set(a.uid,{accounts:a.accounts??f.accounts,chainId:a.chainId??f.chainId,connector:f.connector})}:h})}function S(a){y.getState().status==="connecting"||y.getState().status==="reconnecting"||y.setState(h=>{const f=u.getState().find(b=>b.uid===a.uid);return f?(f.emitter.listenerCount("connect")&&f.emitter.off("connect",I),f.emitter.listenerCount("change")||f.emitter.on("change",I),f.emitter.listenerCount("disconnect")||f.emitter.on("disconnect",C),{...h,connections:new Map(h.connections).set(a.uid,{accounts:a.accounts,chainId:a.chainId,connector:f}),current:a.uid,status:"connected"}):h})}function C(a){y.setState(h=>{const f=h.connections.get(a.uid);if(f){const w=f.connector;w.emitter.listenerCount("change")&&f.connector.emitter.off("change",I),w.emitter.listenerCount("disconnect")&&f.connector.emitter.off("disconnect",C),w.emitter.listenerCount("connect")||f.connector.emitter.on("connect",S)}if(h.connections.delete(a.uid),h.connections.size===0)return{...h,connections:new Map,current:null,status:"disconnected"};const b=h.connections.values().next().value;return{...h,connections:new Map(h.connections),current:b.connector.uid}})}return{get chains(){return d.getState()},get connectors(){return u.getState()},storage:t,getClient:g,get state(){return y.getState()},setState(a){let h;typeof a=="function"?h=a(y.getState()):h=a;const f=v();typeof h!="object"&&(h=f),Object.keys(f).some(w=>!(w in h))&&(h=f),y.setState(h,!0)},subscribe(a,h,f){return y.subscribe(a,h,f?{...f,fireImmediately:f.emitImmediately}:void 0)},_internal:{mipd:s,store:y,ssr:!!o,syncConnectedChain:r,transports:i.transports,chains:{setState(a){const h=typeof a=="function"?a(d.getState()):a;if(h.length!==0)return d.setState(h,!0)},subscribe(a){return d.subscribe(a)}},connectors:{providerDetailToConnector:p,setup:c,setState(a){return u.setState(typeof a=="function"?a(u.getState()):a,!0)},subscribe(a){return u.subscribe(a)}},events:{change:I,connect:S,disconnect:C}}}}function ne(e,n,t){const r=e[n.name];if(typeof r=="function")return r;const o=e[t];return typeof o=="function"?o:i=>n(e,i)}async function et(e,n){var r;let t;if(typeof n.connector=="function"?t=e._internal.connectors.setup(n.connector):t=n.connector,t.uid===e.state.current)throw new Ge;try{e.setState(s=>({...s,status:"connecting"})),t.emitter.emit("message",{type:"connecting"});const o=await t.connect({chainId:n.chainId}),i=o.accounts;return t.emitter.off("connect",e._internal.events.connect),t.emitter.on("change",e._internal.events.change),t.emitter.on("disconnect",e._internal.events.disconnect),await((r=e.storage)==null?void 0:r.setItem("recentConnectorId",t.id)),e.setState(s=>({...s,connections:new Map(s.connections).set(t.uid,{accounts:i,chainId:o.chainId,connector:t}),current:t.uid,status:"connected"})),{accounts:i,chainId:o.chainId}}catch(o){throw e.setState(i=>({...i,status:i.current?"connected":"disconnected"})),o}}async function tt(e,n={}){var o,i;let t;if(n.connector)t=n.connector;else{const{connections:s,current:d}=e.state,u=s.get(d);t=u==null?void 0:u.connector}const r=e.state.connections;t&&(await t.disconnect(),t.emitter.off("change",e._internal.events.change),t.emitter.off("disconnect",e._internal.events.disconnect),t.emitter.on("connect",e._internal.events.connect),r.delete(t.uid)),e.setState(s=>{if(r.size===0)return{...s,connections:new Map,current:null,status:"disconnected"};const d=r.values().next().value;return{...s,connections:new Map(r),current:d.connector.uid}});{const s=e.state.current;if(!s)return;const d=(o=e.state.connections.get(s))==null?void 0:o.connector;if(!d)return;await((i=e.storage)==null?void 0:i.setItem("recentConnectorId",d.id))}}function ye(e){return typeof e=="number"?e:e==="wei"?0:Math.abs(ke[e])}function be(e){const n=e.state.current,t=e.state.connections.get(n),r=t==null?void 0:t.accounts,o=r==null?void 0:r[0],i=e.chains.find(d=>d.id===(t==null?void 0:t.chainId)),s=e.state.status;switch(s){case"connected":return{address:o,addresses:r,chain:i,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:s};case"reconnecting":return{address:o,addresses:r,chain:i,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!!o,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:s};case"connecting":return{address:o,addresses:r,chain:i,chainId:t==null?void 0:t.chainId,connector:t==null?void 0:t.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:s};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:s}}}async function nt(e,n){const{allowFailure:t=!0,chainId:r,contracts:o,...i}=n,s=e.getClient({chainId:r});return ne(s,$e,"multicall")({allowFailure:t,contracts:o,...i})}function rt(e,n){const{chainId:t,...r}=n,o=e.getClient({chainId:t});return ne(o,We,"readContract")(r)}async function ot(e,n){const{allowFailure:t=!0,blockNumber:r,blockTag:o,...i}=n,s=n.contracts;try{const d=s.reduce((l,g,v)=>{const m=g.chainId??e.state.chainId;return{...l,[m]:[...l[m]||[],{contract:g,index:v}]}},{}),u=()=>Object.entries(d).map(([l,g])=>nt(e,{...i,allowFailure:t,blockNumber:r,blockTag:o,chainId:parseInt(l),contracts:g.map(({contract:v})=>v)})),c=(await Promise.all(u())).flat(),p=Object.values(d).flatMap(l=>l.map(({index:g})=>g));return c.reduce((l,g,v)=>(l&&(l[p[v]]=g),l),[])}catch(d){if(d instanceof de)throw d;const u=()=>s.map(c=>rt(e,{...c,blockNumber:r,blockTag:o}));return t?(await Promise.allSettled(u())).map(c=>c.status==="fulfilled"?{result:c.value,status:"success"}:{error:c.reason,result:void 0,status:"failure"}):await Promise.all(u())}}async function ct(e,n){const{address:t,blockNumber:r,blockTag:o,chainId:i,token:s,unit:d="ether"}=n;if(s)try{return ae(e,{balanceAddress:t,chainId:i,symbolType:"string",tokenAddress:s})}catch(g){if(g instanceof de){const v=await ae(e,{balanceAddress:t,chainId:i,symbolType:"bytes32",tokenAddress:s}),m=qe(Ee(v.symbol,{dir:"right"}));return{...v,symbol:m}}throw g}const u=e.getClient({chainId:i}),p=await ne(u,xe,"getBalance")(r?{address:t,blockNumber:r}:{address:t,blockTag:o}),l=e.chains.find(g=>g.id===i)??u.chain;return{decimals:l.nativeCurrency.decimals,formatted:le(p,ye(d)),symbol:l.nativeCurrency.symbol,value:p}}async function ae(e,n){const{balanceAddress:t,chainId:r,symbolType:o,tokenAddress:i,unit:s}=n,d={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:o}]}],address:i},[u,c,p]=await ot(e,{allowFailure:!1,contracts:[{...d,functionName:"balanceOf",args:[t],chainId:r},{...d,functionName:"decimals",chainId:r},{...d,functionName:"symbol",chainId:r}]}),l=le(u??"0",ye(s??c));return{decimals:c,formatted:l,symbol:p,value:u}}function it(e){return e.state.chainId}function W(e,n){if(e===n)return!0;if(e&&n&&typeof e=="object"&&typeof n=="object"){if(e.constructor!==n.constructor)return!1;let t,r;if(Array.isArray(e)&&Array.isArray(n)){if(t=e.length,t!==n.length)return!1;for(r=t;r--!==0;)if(!W(e[r],n[r]))return!1;return!0}if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();const o=Object.keys(e);if(t=o.length,t!==Object.keys(n).length)return!1;for(r=t;r--!==0;)if(!Object.prototype.hasOwnProperty.call(n,o[r]))return!1;for(r=t;r--!==0;){const i=o[r];if(i&&!W(e[i],n[i]))return!1}return!0}return e!==e&&n!==n}let B=[];function we(e){const n=[...e.state.connections.values()];return e.state.status==="reconnecting"||W(B,n)?B:(B=n,n)}let H=[];function st(e){const n=e.connectors;return W(H,n)?H:(H=n,n)}let Q=!1;async function at(e,n={}){var c,p;if(Q)return[];Q=!0,e.setState(l=>({...l,status:l.current?"reconnecting":"connecting"}));const t=[];if((c=n.connectors)!=null&&c.length)for(const l of n.connectors){let g;typeof l=="function"?g=e._internal.connectors.setup(l):g=l,t.push(g)}else t.push(...e.connectors);let r;try{r=await((p=e.storage)==null?void 0:p.getItem("recentConnectorId"))}catch{}const o={};for(const[,l]of e.state.connections)o[l.connector.id]=1;r&&(o[r]=0);const i=Object.keys(o).length>0?[...t].sort((l,g)=>(o[l.id]??10)-(o[g.id]??10)):t;let s=!1;const d=[],u=[];for(const l of i){const g=await l.getProvider().catch(()=>{});if(!g||u.some(O=>O===g)||!await l.isAuthorized())continue;const m=await l.connect({isReconnecting:!0}).catch(()=>null);m&&(l.emitter.off("connect",e._internal.events.connect),l.emitter.on("change",e._internal.events.change),l.emitter.on("disconnect",e._internal.events.disconnect),e.setState(O=>{const y=new Map(s?O.connections:new Map).set(l.uid,{accounts:m.accounts,chainId:m.chainId,connector:l});return{...O,current:s?O.current:l.uid,connections:y}}),d.push({accounts:m.accounts,chainId:m.chainId,connector:l}),u.push(g),s=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(s?e.setState(l=>({...l,status:"connected"})):e.setState(l=>({...l,connections:new Map,current:null,status:"disconnected"}))),Q=!1,d}function ut(e,n){const{onChange:t}=n;return e.subscribe(()=>be(e),t,{equalityFn(r,o){const{connector:i,...s}=r,{connector:d,...u}=o;return W(s,u)&&(i==null?void 0:i.id)===(d==null?void 0:d.id)&&(i==null?void 0:i.uid)===(d==null?void 0:d.uid)}})}function dt(e,n){const{onChange:t}=n;return e.subscribe(r=>r.chainId,t)}function lt(e,n){const{onChange:t}=n;return e.subscribe(()=>we(e),t,{equalityFn:W})}function ft(e,n){const{onChange:t}=n;return e._internal.connectors.subscribe((r,o)=>{t(Object.values(r),o)})}function ht(e,n){const{initialState:t,reconnectOnMount:r}=n;return t&&!e._internal.store.persist.hasHydrated()&&e.setState({...t,connections:r?t.connections:new Map,status:r?"reconnecting":"disconnected"}),{async onMount(){var o;if(e._internal.ssr){await e._internal.store.persist.rehydrate();const i=(o=e._internal.mipd)==null?void 0:o.getProviders().map(e._internal.connectors.providerDetailToConnector).map(e._internal.connectors.setup);e._internal.connectors.setState(s=>[...s,...i??[]])}r?at(e):e.storage&&e.setState(i=>({...i,connections:new Map}))}}}const zt={getItem(e){return typeof window>"u"?null:pt(document.cookie,e)??null},setItem(e,n){typeof window>"u"||(document.cookie=`${e}=${n}`)},removeItem(e){typeof window>"u"||(document.cookie=`${e}=;max-age=-1`)}};function pt(e,n){const t=e.split("; ").find(r=>r.startsWith(`${n}=`));if(t)return t.substring(n.length+1)}const ve=Symbol(),Lt={install(e,n){const{config:t,reconnectOnMount:r=!0}=n;e.provide(ve,t);const{onMount:o}=ht(t,{...n,reconnectOnMount:r});o()}},gt="0.0.10",mt=()=>`@wagmi/vue@${gt}`;class Ie extends K{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/vue"}get version(){return mt()}}class yt extends Ie{constructor(){super("No `config` found in Vue context, use `WagmiPlugin` to properly initialize the library.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiPluginNotFoundError"})}}class bt extends Ie{constructor(){super("Wagmi composables can only be used inside `setup()` function or functions that support injection context.",{docsPath:"/api/TODO"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiInjectionContextError"})}}function wt(e,n){Object.keys(e).forEach(t=>{e[t]=n[t]})}function A(e={}){const n=N(e);if(n.config)return n.config;if(!Re())throw new bt;const t=Ue(ve);if(!t)throw new yt;return t}function Vt(e={}){const n=A(e),t=Ne(be(n)),r=ut(n,{onChange(o){wt(t,o)}});return q(()=>r()),Te(Y(t))}function X(e,n){if(n){const t=n(e);if(t===void 0&&fe(e)||t!==void 0)return t}if(Array.isArray(e))return e.map(t=>X(t,n));if(typeof e=="object"&&vt(e)){const t=Object.entries(e).map(([r,o])=>[r,X(o,n)]);return Object.fromEntries(t)}return e}function Ce(e){return X(e,n=>{if(fe(n))return Ce(N(n))})}function vt(e){if(Object.prototype.toString.call(e)!=="[object Object]")return!1;const n=Object.getPrototypeOf(e);return n===null||n===Object.prototype}function It(e){return JSON.stringify(e,(n,t)=>Ct(t)?Object.keys(t).sort().reduce((r,o)=>(r[o]=t[o],r),{}):typeof t=="bigint"?t.toString():t)}function Ct(e){if(!ue(e))return!1;const n=e.constructor;if(typeof n>"u")return!0;const t=n.prototype;return!(!ue(t)||!t.hasOwnProperty("isPrototypeOf"))}function ue(e){return Object.prototype.toString.call(e)==="[object Object]"}function Ot(e){const{_defaulted:n,behavior:t,gcTime:r,initialData:o,initialDataUpdatedAt:i,maxPages:s,meta:d,networkMode:u,queryFn:c,queryHash:p,queryKey:l,queryKeyHashFn:g,retry:v,retryDelay:m,structuralSharing:O,getPreviousPageParam:y,getNextPageParam:I,initialPageParam:S,_optimisticResults:C,enabled:a,notifyOnChangeProps:h,placeholderData:f,refetchInterval:b,refetchIntervalInBackground:w,refetchOnMount:k,refetchOnReconnect:P,refetchOnWindowFocus:z,retryOnMount:j,select:M,staleTime:Oe,suspense:re,throwOnError:Wt,config:qt,connector:Et,query:xt,...Se}=e;return Se}function St(e){return{mutationFn(n){return et(e,n)},mutationKey:["connect"]}}function jt(e){return{mutationFn(n){return tt(e,n)},mutationKey:["disconnect"]}}function _t(e,n={}){return{async queryFn({queryKey:t}){const{address:r,scopeKey:o,...i}=t[1];if(!r)throw new Error("address is required");return await ct(e,{...i,address:r})??null},queryKey:Pt(n)}}function Pt(e={}){return["balance",Ot(e)]}function Mt(e){const n=T(()=>({...N(e),queryKeyHashFn:It})),t=Fe(n);return t.queryKey=N(n).queryKey,t}function At(e={}){const n=A(e),t=ee(it(n)),r=dt(n,{onChange(o){t.value=o}});return q(()=>r()),Y(t)}function Ht(e={}){const n=T(()=>Ce(e)),t=A(n),r=At({config:t}),o=T(()=>{const{address:i,chainId:s=r.value,query:d={}}=n.value,u=_t(t,{...n.value,chainId:s}),c=!!(i&&(d.enabled??!0));return{...d,...u,enabled:c}});return Mt(o)}function kt(e={}){const n=A(e),t=ee(st(n)),r=ft(n,{onChange(o){t.value=o}});return q(()=>r()),t}function Qt(e={}){const{mutation:n}=e,t=A(e),r=St(t),{mutate:o,mutateAsync:i,...s}=he({...n,...r}),d=t.subscribe(({status:u})=>u,(u,c)=>{c==="connected"&&u==="disconnected"&&s.reset()});return q(()=>d()),{...s,connect:o,connectAsync:i,connectors:kt({config:t}).value}}function $t(e={}){const n=A(e),t=ee(we(n)),r=lt(n,{onChange(o){t.value=o}});return q(()=>r()),Y(t)}function Jt(e={}){const{mutation:n}=e,t=A(e),r=$t({config:t}),o=jt(t),{mutate:i,mutateAsync:s,...d}=he({...n,...o});return{...d,connectors:T(()=>r.value.map(u=>u.connector)),disconnect:i,disconnectAsync:s}}export{G as C,Lt as W,Kt as a,Qe as b,Ft as c,zt as d,Vt as e,Qt as f,Jt as g,Ht as u};
