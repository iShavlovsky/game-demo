function L(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function G(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function H(e,...t){if(!G(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function R(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");L(e.outputLen),L(e.blockLen)}function y(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function F(e,t){H(e);const s=t.outputLen;if(e.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}const A=BigInt(2**32-1),O=BigInt(32);function X(e,t=!1){return t?{h:Number(e&A),l:Number(e>>O&A)}:{h:Number(e>>O&A)|0,l:Number(e&A)|0}}function P(e,t=!1){let s=new Uint32Array(e.length),i=new Uint32Array(e.length);for(let o=0;o<e.length;o++){const{h:r,l:n}=X(e[o],t);[s[o],i[o]]=[r,n]}return[s,i]}const W=(e,t,s)=>e<<s|t>>>32-s,K=(e,t,s)=>t<<s|e>>>32-s,q=(e,t,s)=>t<<s-32|e>>>64-s,v=(e,t,s)=>e<<s-32|t>>>64-s,g=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function z(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function B(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function d(e,t){return e<<32-t|e>>>t}const E=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function J(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function S(e){for(let t=0;t<e.length;t++)e[t]=J(e[t])}function Q(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function k(e){return typeof e=="string"&&(e=Q(e)),H(e),e}function dt(...e){let t=0;for(let i=0;i<e.length;i++){const o=e[i];H(o),t+=o.length}const s=new Uint8Array(t);for(let i=0,o=0;i<e.length;i++){const r=e[i];s.set(r,o),o+=r.length}return s}class U{clone(){return this._cloneInto()}}function M(e){const t=i=>e().update(k(i)).digest(),s=e();return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=()=>e(),t}function xt(e=32){if(g&&typeof g.getRandomValues=="function")return g.getRandomValues(new Uint8Array(e));if(g&&typeof g.randomBytes=="function")return g.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const V=[],D=[],N=[],Y=BigInt(0),w=BigInt(1),Z=BigInt(2),$=BigInt(7),tt=BigInt(256),et=BigInt(113);for(let e=0,t=w,s=1,i=0;e<24;e++){[s,i]=[i,(2*s+3*i)%5],V.push(2*(5*i+s)),D.push((e+1)*(e+2)/2%64);let o=Y;for(let r=0;r<7;r++)t=(t<<w^(t>>$)*et)%tt,t&Z&&(o^=w<<(w<<BigInt(r))-w);N.push(o)}const[st,nt]=P(N,!0),T=(e,t,s)=>s>32?q(e,t,s):W(e,t,s),C=(e,t,s)=>s>32?v(e,t,s):K(e,t,s);function it(e,t=24){const s=new Uint32Array(10);for(let i=24-t;i<24;i++){for(let n=0;n<10;n++)s[n]=e[n]^e[n+10]^e[n+20]^e[n+30]^e[n+40];for(let n=0;n<10;n+=2){const h=(n+8)%10,f=(n+2)%10,u=s[f],a=s[f+1],c=T(u,a,1)^s[h],b=C(u,a,1)^s[h+1];for(let l=0;l<50;l+=10)e[n+l]^=c,e[n+l+1]^=b}let o=e[2],r=e[3];for(let n=0;n<24;n++){const h=D[n],f=T(o,r,h),u=C(o,r,h),a=V[n];o=e[a],r=e[a+1],e[a]=f,e[a+1]=u}for(let n=0;n<50;n+=10){for(let h=0;h<10;h++)s[h]=e[n+h];for(let h=0;h<10;h++)e[n+h]^=~s[(h+2)%10]&s[(h+4)%10]}e[0]^=st[i],e[1]^=nt[i]}s.fill(0)}class _ extends U{constructor(t,s,i,o=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=i,this.enableXOF=o,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,L(i),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=z(this.state)}keccak(){E||S(this.state32),it(this.state32,this.rounds),E||S(this.state32),this.posOut=0,this.pos=0}update(t){y(this);const{blockLen:s,state:i}=this;t=k(t);const o=t.length;for(let r=0;r<o;){const n=Math.min(s-this.pos,o-r);for(let h=0;h<n;h++)i[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:i,blockLen:o}=this;t[i]^=s,(s&128)!==0&&i===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){y(this,!1),H(t),this.finish();const s=this.state,{blockLen:i}=this;for(let o=0,r=t.length;o<r;){this.posOut>=i&&this.keccak();const n=Math.min(i-this.posOut,r-o);t.set(s.subarray(this.posOut,this.posOut+n),o),this.posOut+=n,o+=n}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return L(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(F(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:i,outputLen:o,rounds:r,enableXOF:n}=this;return t||(t=new _(s,i,o,n,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=i,t.outputLen=o,t.enableXOF=n,t.destroyed=this.destroyed,t}}const ot=(e,t,s)=>M(()=>new _(t,e,s)),pt=ot(1,136,256/8);function rt(e,t,s,i){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,s,i);const o=BigInt(32),r=BigInt(4294967295),n=Number(s>>o&r),h=Number(s&r),f=i?4:0,u=i?0:4;e.setUint32(t+f,n,i),e.setUint32(t+u,h,i)}function ht(e,t,s){return e&t^~e&s}function ct(e,t,s){return e&t^e&s^t&s}class ft extends U{constructor(t,s,i,o){super(),this.blockLen=t,this.outputLen=s,this.padOffset=i,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=B(this.buffer)}update(t){y(this);const{view:s,buffer:i,blockLen:o}=this;t=k(t);const r=t.length;for(let n=0;n<r;){const h=Math.min(o-this.pos,r-n);if(h===o){const f=B(t);for(;o<=r-n;n+=o)this.process(f,n);continue}i.set(t.subarray(n,n+h),this.pos),this.pos+=h,n+=h,this.pos===o&&(this.process(s,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){y(this),F(t,this),this.finished=!0;const{buffer:s,view:i,blockLen:o,isLE:r}=this;let{pos:n}=this;s[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>o-n&&(this.process(i,0),n=0);for(let c=n;c<o;c++)s[c]=0;rt(i,o-8,BigInt(this.length*8),r),this.process(i,0);const h=B(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=f/4,a=this.get();if(u>a.length)throw new Error("_sha2: outputLen bigger than state");for(let c=0;c<u;c++)h.setUint32(4*c,a[c],r)}digest(){const{buffer:t,outputLen:s}=this;this.digestInto(t);const i=t.slice(0,s);return this.destroy(),i}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:s,buffer:i,length:o,finished:r,destroyed:n,pos:h}=this;return t.length=o,t.pos=h,t.finished=r,t.destroyed=n,o%s&&t.buffer.set(i),t}}const ut=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),x=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);class at extends ft{constructor(){super(64,32,8,!1),this.A=x[0]|0,this.B=x[1]|0,this.C=x[2]|0,this.D=x[3]|0,this.E=x[4]|0,this.F=x[5]|0,this.G=x[6]|0,this.H=x[7]|0}get(){const{A:t,B:s,C:i,D:o,E:r,F:n,G:h,H:f}=this;return[t,s,i,o,r,n,h,f]}set(t,s,i,o,r,n,h,f){this.A=t|0,this.B=s|0,this.C=i|0,this.D=o|0,this.E=r|0,this.F=n|0,this.G=h|0,this.H=f|0}process(t,s){for(let c=0;c<16;c++,s+=4)p[c]=t.getUint32(s,!1);for(let c=16;c<64;c++){const b=p[c-15],l=p[c-2],m=d(b,7)^d(b,18)^b>>>3,I=d(l,17)^d(l,19)^l>>>10;p[c]=I+p[c-7]+m+p[c-16]|0}let{A:i,B:o,C:r,D:n,E:h,F:f,G:u,H:a}=this;for(let c=0;c<64;c++){const b=d(h,6)^d(h,11)^d(h,25),l=a+b+ht(h,f,u)+ut[c]+p[c]|0,I=(d(i,2)^d(i,13)^d(i,22))+ct(i,o,r)|0;a=u,u=f,f=h,h=n+l|0,n=r,r=o,o=i,i=l+I|0}i=i+this.A|0,o=o+this.B|0,r=r+this.C|0,n=n+this.D|0,h=h+this.E|0,f=f+this.F|0,u=u+this.G|0,a=a+this.H|0,this.set(i,o,r,n,h,f,u,a)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const bt=M(()=>new at);class j extends U{constructor(t,s){super(),this.finished=!1,this.destroyed=!1,R(t);const i=k(s);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,r=new Uint8Array(o);r.set(i.length>o?t.create().update(i).digest():i);for(let n=0;n<r.length;n++)r[n]^=54;this.iHash.update(r),this.oHash=t.create();for(let n=0;n<r.length;n++)r[n]^=106;this.oHash.update(r),r.fill(0)}update(t){return y(this),this.iHash.update(t),this}digestInto(t){y(this),H(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:s,iHash:i,finished:o,destroyed:r,blockLen:n,outputLen:h}=this;return t=t,t.finished=o,t.destroyed=r,t.blockLen=n,t.outputLen=h,t.oHash=s._cloneInto(t.oHash),t.iHash=i._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const lt=(e,t,s)=>new j(e,t).update(s).digest();lt.create=(e,t)=>new j(e,t);export{dt as c,lt as h,pt as k,xt as r,bt as s};
